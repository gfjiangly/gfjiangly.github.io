<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记录字节算法实习岗面试的一道算法题</title>
      <link href="/leetcode/leetcode_71.html"/>
      <url>/leetcode/leetcode_71.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p><p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">"/home/"</span></span><br><span class="line">输出：<span class="string">"/home"</span></span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">"/../"</span></span><br><span class="line">输出：<span class="string">"/"</span></span><br><span class="line">解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">"/home//foo/"</span></span><br><span class="line">输出：<span class="string">"/home/foo"</span></span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="comment">"/a/./b/../../c/"</span></span><br><span class="line">输出：<span class="comment">"/c"</span></span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="comment">"/a/../../b/../c//.//"</span></span><br><span class="line">输出：<span class="comment">"/c"</span></span><br></pre></td></tr></table></figure><p><strong>示例 6：</strong></p><figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">"/a//b////c/d//././/.."</span></span><br><span class="line">输出：<span class="string">"/a/b/c"</span></span><br></pre></td></tr></table></figure><h2 id="逻辑清晰的解答"><a href="#逻辑清晰的解答" class="headerlink" title="逻辑清晰的解答"></a>逻辑清晰的解答</h2><p>这道题是面试字节暑期实习算法岗的一道算法题。没通过AC，思路也没写对。通过这次面试，让我明白了原来“算法题”不仅仅考察算法，也考察我们的逻辑清晰度，这道题几乎没有什么算法在里面，只要我们考虑全面，基本都可以做出来。写的代码不被AC，或者思路不正确的大部分原因是输入情况未考虑全面，例如本题，当时我仅考虑到：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 含有一个点</span><br><span class="line"><span class="number">2.</span> 含有两个点</span><br><span class="line"><span class="number">3.</span> 开头有没有<span class="string">'/'</span>，没有斜杠要怎么处理(与面试官讨论)</span><br><span class="line"><span class="number">4.</span> 结尾有没有<span class="string">'/'</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 甚至误以为一个文件名只有一个字符，切到上一级目录使用了固定偏移(错的太多了)</span><br><span class="line"><span class="number">6.</span> 甚至没有考虑还有两个连续的<span class="string">'/'</span></span><br><span class="line"><span class="number">7.</span> 更别提考虑连续多级<span class="string">'..'</span></span><br></pre></td></tr></table></figure><p>总之有太多case没考虑到，这提醒我们，在写代码之前一定不能只针对一种case写。很有可能自己想的算法本身就是错误的、行不通的。只有全面考虑多种case，并且认为自己的算法能够处理这么多种情况，或者很容易扩展处理，才可以写代码。</p><p>我总想着把所有操作融入到一个循环中，以此提高效率，而没有从解决问题的本身出发。搞清楚本题本身是最重要的，效率其次之~</p><p>这道题，我们延续数据清洗的思路，对字符串路径以此按<code>/ . ..</code>顺序清洗，然后最后再连接符合要求的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = path.size();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> path;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理'/'</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span> last_seq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="comment">// 从左向右处理</span></span><br><span class="line">            <span class="keyword">if</span> (path[i] == <span class="string">'/'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - last_seq &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    st.push(path.substr(last_seq+<span class="number">1</span>, i-last_seq<span class="number">-1</span>));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s "</span>, st.top().c_str());</span><br><span class="line">                &#125;</span><br><span class="line">                last_seq = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path[size<span class="number">-1</span>] != <span class="string">'/'</span>) st.push(path.substr(last_seq+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理'.'</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; st_c;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="comment">// 从右向左处理</span></span><br><span class="line">            <span class="keyword">if</span> (st.top().compare(<span class="string">"."</span>) != <span class="number">0</span>) st_c.push(st.top());</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理".."</span></span><br><span class="line">        <span class="keyword">int</span> last_nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st_c.empty()) &#123;</span><br><span class="line">            <span class="comment">// 从右向左处理</span></span><br><span class="line">            <span class="keyword">if</span> (st_c.front().compare(<span class="string">".."</span>) == <span class="number">0</span>) ++last_nums;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (last_nums == <span class="number">0</span>) st.push(st_c.front());</span><br><span class="line">                <span class="keyword">if</span> (last_nums &gt; <span class="number">0</span>) --last_nums;</span><br><span class="line">            &#125;</span><br><span class="line">            st_c.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接字符串</span></span><br><span class="line">        <span class="built_in">string</span> new_path = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="comment">// 从左向右处理</span></span><br><span class="line">            new_path += <span class="string">"/"</span> + st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_path.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">return</span> new_path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果还需要处理其它情况，也非常容易在此基础上扩展。逻辑复杂的题，代码运行效率往往不是首先要考虑的因素。首先应该要以清晰的代码梳理逻辑，通过所有情况的测试，然后才去考虑如何优化效率。</p><p>PS：很多情况下逻辑比效率更重要。错误的目标会导致白费的努力~</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存一致性模型</title>
      <link href="/cpu_parallel/memory_consistency_model.html"/>
      <url>/cpu_parallel/memory_consistency_model.html</url>
      
        <content type="html"><![CDATA[<p>内存一致性模型（memory consistency model）是用来描述多线程对共享存储器的访问行为，在不同的内存一致性模型里，多线程对共享存储器的访问行为有非常大的差别。这些差别会严重影响程序的执行逻辑，甚至会造成软件逻辑问题。在后面的介绍中，我们将分析不同的一致性模型里，多线程的内存访问乱序问题。</p><p>PS：内存一致性模型实际上是由硬件带来的，当软件人员思考这种模型时就“跨层”了。而计算机科学中最重要的思想之一就是：分层。只有当我们不满足于当前层提供的能力或性能时，才会考虑”跨层”。多线程程序的出现本身就是为了提高程序性能。</p><p>目前有多种内存一致性模型：</p><ul><li>顺序一致模型（sequential consistency model，SC）</li><li>完全存储定序（total store order，TSO）</li><li>部分存储定序（part store order，PSO）</li><li>宽松存储模型（relax memory order，RMO）</li></ul><h2 id="SC：顺序一致性"><a href="#SC：顺序一致性" class="headerlink" title="SC：顺序一致性"></a>SC：顺序一致性</h2><p>顺序一致性是最简单的内存模型，也称为强定序模型。CPU会按照程序顺序来执行所有的load与store动作，即按照它们在程序中出现的次序来执行。从主存储器和CPU的角度来看，load和store是顺序地对主存储器进行访问。PS：可以想象成只有共享存储，没有独立存储。</p><p>顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行。 </li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。</li></ul><p>在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。顺序一致性内存模型为程序员提供的视图如下：</p><p><img src="/images/16729e0d47ba4983" alt="img"></p><p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读 /写操作。从上面的示意图我们可以看出，在任意时间点最多只能有一个线程可以 连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读 /写操作串行化（即在顺序一致性模型中，所有操作之间具有全序关系）。</p><p>为了更好的理解，下面我们通过一个示意图来对顺序一致性模型的特性做进一步的说明。</p><p>假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B 线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2- &gt;B3。</p><p><img src="/images/16729f25688d4a4e" alt="img"></p><p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1- &gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p><h2 id="TSO：完全存储定序"><a href="#TSO：完全存储定序" class="headerlink" title="TSO：完全存储定序"></a>TSO：完全存储定序</h2><p>为了提高CPU的性能，芯片设计人员在CPU中包含了一个存储缓存区（store buffer），它的作用是为store指令提供缓冲，使得CPU不用等待存储器的响应。所以对于写而言，只要store buffer里还有空间，写就只需要1个时钟周期（哪怕是ARM-A76的L1 cache，访问一次也需要3个cycles，所以store buffer的存在可以很好的减少写开销），但这也引入了一个访问乱序的问题。</p><p>相比于以前的内存模型而言，store的时候数据会先被放到store buffer里面，然后再被写到L1 cache里。</p><p><img src="/images/image-20200217113525865.png" alt="image-20200217113525865"></p><p>首先我们思考单核上的3条指令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S1：store flag= set</span><br><span class="line">S2：load <span class="attribute">r1</span>=data</span><br><span class="line">S3：store <span class="attribute">b</span>=set</span><br></pre></td></tr></table></figure><p>如果在顺序存储模型中，S1肯定会比S2先执行。但是如果在加入了store buffer之后，S1将指令放到了store buffer后会立刻返回，这个时候会立刻执行S2。S2是read指令，CPU必须等到数据读取到r1后才会继续执行。这样很可能S1的store flag=set指令还在store buffer上，而S2的load指令可能已经执行完（特别是data在cache上存在，而flag没在cache中的时候。这个时候CPU往往会先执行S2，这样可以减少等待时间）</p><p>这里就可以看出再加入了store buffer之后，内存一致性模型就发生了改变。引入了<strong>store-load乱序</strong>。</p><p>如果我们定义store buffer必须严格按照FIFO的次序将数据发送到主存（所谓的FIFO表示先进入store buffer的指令数据必须先于后面的指令数据写到存储器中），这样S3必须要在S1之后执行，CPU能够保证store指令的存储顺序，这种内存模型就叫做完全存储定序（TSO）。</p><p>经典的例子：</p><p><img src="/images/image-20200217114212933.png" alt="image-20200217114212933"></p><p>在SC模型里，C1与C2是严格按照顺序执行的，代码可能的执行顺序如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">S1</span> <span class="built_in">S2</span> L1 L2</span><br><span class="line"><span class="built_in">S1</span> L1 <span class="built_in">S2</span> L2</span><br><span class="line"><span class="built_in">S1</span> L1 L2 <span class="built_in">S2</span></span><br><span class="line">L1 L2 <span class="built_in">S1</span> <span class="built_in">S2</span></span><br><span class="line">L1 <span class="built_in">S1</span> <span class="built_in">S2</span> L2</span><br><span class="line">L1 <span class="built_in">S1</span> L2 <span class="built_in">S2</span></span><br></pre></td></tr></table></figure><p>由于SC会严格按照顺序进行，最终我们看到的结果是至少有一个CORE的r1值为NEW，或者都为NEW。</p><p>在TSO模型里，由于store buffer的存在，L1和S1的store指令会被先放到store buffer里面，然后CPU会继续执行后面的load指令。Store buffer中的数据可能还没有来得及往存储器中写，这个时候我们可能看到C1和C2的r1都为0的情况。</p><p>所以，我们可以看到，在store buffer被引入之后，内存一致性模型已经发生了变化（从SC模型变为了TSO模型），会出现store-load乱序的情况，这就造成了代码执行逻辑与我们预先设想不相同的情况。而且随着内存一致性模型越宽松（通过允许更多形式的乱序读写访问），这种情况会越剧烈，会给多线程编程带来很大的挑战。</p><h2 id="PSO：部分存储定序"><a href="#PSO：部分存储定序" class="headerlink" title="PSO：部分存储定序"></a>PSO：部分存储定序</h2><p>芯片设计人员并不满足TSO带来的性能提升，于是他们在TSO模型的基础上继续放宽内存访问限制，允许CPU以非FIFO来处理store buffer缓冲区中的指令。CPU只保证地址相关指令在store buffer中才会以FIFO的形式进行处理，而其他的则可以乱序处理，所以这被称为部分存储定序（PSO）。</p><p><img src="/images/image-20200217114651549.png" alt="image-20200217114651549"></p><p>S1与S2是地址无关的store指令，cpu执行的时候都会将其推到store buffer中。如果这个时候flag在C1的cahe中不存在，那么CPU会优先将S2的store执行完，然后等flag缓存到C1的cache之后，再执行store data=NEW指令。</p><p>这个时候可能的执行顺序：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">S2</span> L1 L2 <span class="built_in">S1</span></span><br></pre></td></tr></table></figure><p>这样在C1将data设置为NEW之前，C2已经执行完，r2最终的结果会为0，而不是我们期望的NEW，这样PSO带来的<strong>store-store乱序</strong>将会对我们的代码逻辑造成致命影响。</p><p>从这里可以看到，store-store乱序的时候就会将我们的多线程代码完全击溃。所以在PSO内存模型的架构上编程的时候，要特别注意这些问题。</p><h2 id="RMO：宽松内存模型"><a href="#RMO：宽松内存模型" class="headerlink" title="RMO：宽松内存模型"></a>RMO：宽松内存模型</h2><p>丧心病狂的芯片研发人员为了榨取更多的性能，在PSO模型基础上，更进一步的放宽了内存一致性模型，不仅允许store-load，store-store乱序。还进一步允许load-load，load-store乱序， 只要是地址无关的指令，在读写访问的时候都可以打乱所有load/store的顺序，这就是宽松内存模型（RMO）。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>芯片设计人员为了尽可能的榨取CPU的性能，引入了乱序的内存一致性模型，这些内存模型在多线程的情况下很可能引起软件逻辑问题。为了解决在有些一致性模型上可能出现的内存访问乱序问题，芯片设计人员提供给了内存屏障指令，用来禁止指令处的乱序。</p><p>内存屏障的最根本的作用就是提供一个机制，要求CPU在这个时候必须以某种顺序一致性模型的方式来处理load与store指令，这样才不会出现内存访问不一致的情况。</p><p>对于TSO和PSO模型，内存屏障只需要在store-load/store-store时需要（写内存屏障），最简单的一种方式就是内存屏障指令必须保证store buffer数据全部被清空的时候才继续往后面执行，这样就能保证其与SC模型的执行顺序一致。</p><p>而对于RMO，在PSO的基础上又引入了load-load与load-store乱序。RMO的读内存屏障就要保证前面的load指令必须先于后面的load/store指令先执行，不允许将其访问提前执行。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.wowotech.net/memory_management/456.html" target="_blank" rel="noopener">http://www.wowotech.net/memory_management/456.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步关系</title>
      <link href="/cpu_parallel/the-synchronizes-with-relation.html"/>
      <url>/cpu_parallel/the-synchronizes-with-relation.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自：<a href="https://preshing.com/20130823/the-synchronizes-with-relation/" target="_blank" rel="noopener">https://preshing.com/20130823/the-synchronizes-with-relation/</a></p><p>略有修改</p></blockquote><h2 id="同步关系"><a href="#同步关系" class="headerlink" title="同步关系"></a>同步关系</h2><p>“ <em>与…同步</em> ”(<em>Synchronizes-with</em>)是语言设计者发明的一个术语，用于描述确保原子操作（甚至是非原子操作）的内存效果对其他线程可见的方式。在编写无锁代码时，这是理想的保证，因为您可以使用它来避免由内存重新排序引起的<a href="http://preshing.com/20121019/this-is-why-they-call-it-a-weakly-ordered-cpu" target="_blank" rel="noopener">不受欢迎的意外</a>。</p><p>“ <em>与…同步</em> ”是一个相当现代的计算机科学术语。您可以在C ++ 11，Java 5+和LLVM的规范中找到它，所有这些规范都是在最近10年内发布的。每个规范都定义了该术语，然后使用它为程序员提供正式保证。他们的共同点是，每当两个操作之间存在<em>同步</em>关系（通常在不同的线程上）时，这些操作之间也就存在<a href="http://preshing.com/20130702/the-happens-before-relation" target="_blank" rel="noopener"><em>happens-before</em>的关系</a>。</p><p><img src="/images/implies.png" alt="img"></p><p>在深入探讨之前，我将为您提供一个小的洞见：在每个 <em>与同步</em> 的关系中，您应该能够识别两个关键要素，我将它们称为<strong>保护变量</strong>和<strong>有效负载</strong>。有效负载是在线程之间传播的一组数据，而保护变量则保护对有效负载的访问。我会指出这些成分。</p><p>现在，让我们来看一个使用C ++ 11原子的熟悉示例。</p><h2 id="Write-Release可以与Read-Acquire同步"><a href="#Write-Release可以与Read-Acquire同步" class="headerlink" title="Write-Release可以与Read-Acquire同步"></a>Write-Release可以与Read-Acquire同步</h2><p>假设我们有一个<code>Message</code>结构，该结构由一个线程生成，并由另一个线程使用。它具有以下字段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Message</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">clock_t</span>     tick;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str;</span><br><span class="line">    <span class="keyword">void</span>*       param;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将通过<code>Message</code>在线程之间传递一个实例，方法是将其放在共享的全局变量中。该共享变量充当有效负载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message g_payload;</span><br></pre></td></tr></table></figure><p>现在，没有一种可移植的方法可以使用单个原子操作来填充<code>g_payload</code>。所以我们不会尝试。相反，我们将定义一个单独的原子变量<code>g_guard</code>，以指示是否<code>g_payload</code>准备就绪。您可能会猜到，<code>g_guard</code>它充当我们的保护变量。保护变量<em>必须</em>使用<a href="http://preshing.com/20130618/atomic-vs-non-atomic-operations" target="_blank" rel="noopener">原子操作</a>来操作，因为两个线程将同时对其进行操作，并且其中一个线程执行写操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; g_guard(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>为了<code>g_payload</code>安全地在线程之间传递，我们将使用<code>获取</code>和<code>释放</code>语义，这是我<a href="http://preshing.com/20120913/acquire-and-release-semantics" target="_blank" rel="noopener">之前</a>使用与之非常相似的示例<a href="http://preshing.com/20120913/acquire-and-release-semantics" target="_blank" rel="noopener">编写</a>的主题。如果您已经阅读过该文章，则可以将以下函数的最后一行识别为对的 <strong>Write-Release</strong> 操作<code>g_guard</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendTestMessage</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Copy to shared memory using non-atomic stores.</span></span><br><span class="line">    g_payload.tick  = clock();</span><br><span class="line">    g_payload.str   = <span class="string">"TestMessage"</span>;</span><br><span class="line">    g_payload.param = param;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Perform an atomic write-release to indicate that the message is ready.</span></span><br><span class="line">    g_guard.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一个线程调用时<code>SendTestMessage</code>，第二个线程<code>TryReceiveMessage</code>间歇地调用，重试直到看到返回值<code>true</code>。您将会认出此函数的第一行在<code>g_guard</code>身上为 <strong>Read-Acquire</strong> 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryReceiveMessage</span><span class="params">(Message&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Perform an atomic read-acquire to check whether the message is ready.</span></span><br><span class="line">    <span class="keyword">int</span> ready = g_guard.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ready != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Yes. Copy from shared memory using non-atomic loads.</span></span><br><span class="line">        result.tick  = g_payload.tick;</span><br><span class="line">        result.str   = g_payload.str;</span><br><span class="line">        result.param = g_payload.param;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// No.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您已经关注该博客一段时间，那么您已经知道该示例可以可靠地运行（尽管它只能传递一条消息）。我已经解释了<a href="http://preshing.com/20120913/acquire-and-release-semantics" target="_blank" rel="noopener">获取和释放语义</a>如何引入内存障碍，并给出在工作的C ++ 11应用程序中获取和释放语义的<a href="http://preshing.com/20121019/this-is-why-they-call-it-a-weakly-ordered-cpu" target="_blank" rel="noopener">详细示例</a>。</p><p>另一方面，C ++ 11标准没有任何解释。这是因为标准旨在充当合同或协议，而不是作为教程。只是简单地保证此示例将起作用，而无需进一步说明。在<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf" target="_blank" rel="noopener">工作草案N3337</a> 的第29.3.2节中做出了承诺：</p><blockquote><p>原子操作A对原子对象M执行release操作 <strong>与</strong> 原子操作B对M执行acquire操作并从以A为开始的release序列中的任何副作用中获取其值的 <strong>同步</strong>。（这句话真难理解）</p><p><em>An atomic operation A that performs a release operation on an atomic object M</em> <strong>synchronizes with</strong> <em>an atomic operation B that performs an acquire operation on M and takes its value from any side effect in the release sequence headed by A.</em></p></blockquote><p>值得对此进行分解。在我们的示例中：</p><ul><li><em>原子操作A</em> 是在<code>SendTestMessage</code>执行的<code>write-release</code>。</li><li><em>原子对象M</em> 是保护变量<code>g_guard</code>。</li><li><em>原子操作B</em> 是在<code>TryReceiveMessage</code>中执行的<code>read-acquire</code>。</li></ul><p>至于<code>read-acquire</code>必须“从任何副作用中获取其值”的条件 —— 只需说<code>read-acquire</code>读取由<code>write-release</code>写入的值就足够了。如果发生这种情况，则<em>同步*关系将完成，并且我们已经实现了梦寐以求的线程之间 *happens-before</em> 关系。有些人喜欢称其为<em>synchronize-with</em> 或 <em>happens-before</em> “edge”。</p><p><img src="/images/two-cones.png" alt="img"></p><p>最重要的是，该标准保证（在<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf" target="_blank" rel="noopener">§1.10.11-12中</a>），只要存在<em>synchronizes-with</em> edge，则 <em>happens-before</em> 关系也将扩展到相邻操作。这包括线程1中的边沿<em>之前</em>的所有操作，以及线程2中的边沿<em>之后</em>的所有操作。在上面的示例中，它确保对所有修改<code>g_payload</code>都在另一个线程读取它们时可见。</p><p>编译器供应商如果希望声明其符合C ++ 11，则必须遵守此保证。起初，他们如何做到似乎有些神秘。但是实际上，编译器使用了C ++ 11出现之前，程序员在技术上必须使用的相同技巧，来实现这一诺言。例如，在<a href="http://preshing.com/20121019/this-is-why-they-call-it-a-weakly-ordered-cpu" target="_blank" rel="noopener">这篇文章</a>中，我们看到了ARMv7编译器如何使用一对<code>dmb</code>指令来实现这些操作。PowerPC编译器可以使用<code>lwsync</code>来实现它们，而x86编译器可以仅使用编译器屏障，由于其相对<a href="http://preshing.com/20120930/weak-vs-strong-memory-models" target="_blank" rel="noopener">强的硬件内存模型</a>。</p><p>当然，获取和释放语义并不是C ++ 11独有的。例如，从Java版本5开始，对<code>volatile</code>变量的每次写都是<code>写释放</code>，而对<code>volatile</code>变量的每次读都是<code>读获取</code>。因此，Java中的任何<code>volatile</code>变量都可以充当保护变量，并可用于在线程之间传播任意大小的有效负载。杰里米·曼森（Jeremy Manson）在他的<a href="http://jeremymanson.blogspot.ca/2008/11/what-volatile-means-in-java.html" target="_blank" rel="noopener">Java volatile变量</a>博客文章中对此进行了解释。他甚至使用与上图非常相似的图，称其为“两个锥体”图。</p><p><a href="http://jeremymanson.blogspot.ca/2008/11/what-volatile-means-in-java.html" target="_blank" rel="noopener"><img src="/images/java-volatile.png" alt="img"></a></p><h2 id="这是运行时关系"><a href="#这是运行时关系" class="headerlink" title="这是运行时关系"></a>这是运行时关系</h2><p>在前面的示例中，我们看到了最后一行<code>SendTestMessage</code> <em>与</em> <code>TryReceiveMessage</code>的第一行是如何<em>同步</em> 的。但是不要陷入源代码中语句之间构成<em>与同步</em>关系思考的陷阱。不是！它是基于这些语句在运行时发生的操作之间的关系。</p><p>这种区别很重要，当您考虑它时应该很明显。单个语句可以在运行的进程中执行任意多次。如果<code>TryReceiveMessage</code>调用得太早（在线程1的存储<code>g_guard</code>位置可见之前），则将不会有任何<em>同步</em>关系。</p><p><img src="/images/no-cones.png" alt="img"></p><p>这完全取决于<code>读获取</code>是否看到由<code>写释放</code>写入的值。这就是C ++ 11标准所说的原子操作B必须从原子操作A“获取其值”时的含义。</p><h2 id="实现同步的其他方法"><a href="#实现同步的其他方法" class="headerlink" title="实现同步的其他方法"></a>实现<em>同步</em>的其他方法</h2><p>就像<em>synchronizes-with</em> 不是实现 <em>happens-before</em> 关系的唯一方式一样，一对<code>写释放/读获取</code>操作不是实现<em>synchronizes-with</em> 的唯一方法；C ++ 11原子操作也不是实现获取和释放语义的唯一方法。我在下表中还组织了其他几种方式。请记住，此图表绝不是详尽无遗的。</p><p>PS：下面这张图非常重要，揭示了同步的层次结构</p><p><img src="/images/org-chart.png" alt="img"></p><p>这篇文章中的示例生成了无锁代码（实际上在所有现代编译器和处理器上），但是C ++ 11和Java公开了也会引入<em>与</em>边<em>同步的</em>阻塞操作。例如，解锁互斥锁始终<em>与</em>该互斥锁的后续锁定保持<em>同步</em>。语言规范对此很明确，作为程序员，我们自然希望如此。您可以将互斥锁本身视为保护对象，将受保护的变量视为有效负载。IBM甚至<a href="http://www.ibm.com/developerworks/library/j-jtp03304/" target="_blank" rel="noopener">在2004年发表了有关Java更新的内存模型的文章</a>，其中包含一个“两个锥体”图，该图显示了一对彼此<em>同步</em>的<code>lock/unlock</code>操作。</p><p><a href="http://www.ibm.com/developerworks/library/j-jtp03304/" target="_blank" rel="noopener"><img src="/images/jsr133.png" alt="img"></a></p><p>正如我<a href="http://preshing.com/20120913/acquire-and-release-semantics" target="_blank" rel="noopener">以前文章所示</a>，获取和释放语义也可以使用独立的，明确的屏障指令来实现。换句话说，只要满足正确的条件，release 屏障(rfence)就可以<em>与</em> acquire 屏障(afence)<em>同步</em>。实际上，显式的屏障指令是<a href="http://mintomic.github.io/" target="_blank" rel="noopener">Mintomic</a>中唯一可用的选项，Mintomic是我自己的用于无锁编程的便携式API。我认为，<code>rfence</code>和<code>afence</code>现在在网络上被严重误解了，因此，我接下来可能会写一篇专门的文章。</p><p>最重要的是，仅在语言和API规范指出存在<em>同步的地方，</em>才存在<em>同步</em>关系。在源代码级别定义自己的保证条件是他们的工作。因此，当在C ++ 11 <code>atomics</code>中使用低级顺序约束时，您不能在一些操作上直接<code>std::memory_order_acquire</code>和<code>release</code>，然后希望事情能神奇地解决。您需要确定哪个原子变量是保护对象，什么是有效负载，以及在哪个代码路径中确保<em>同步</em>关系。</p><p>有趣的是，Go编程语言有点违反常规。<a href="http://golang.org/ref/mem" target="_blank" rel="noopener">Go的内存模型</a>已明确指定，该规范不会在任何地方使用术语“ <em>与…同步</em> ”。它只是坚持使用“ <em>happens-before</em> ”一词，这也不错，因为很明显，任何 <em>与之同步</em> 可以扮演角色，<em>happens-before</em> 也可以扮演。也许Go的作者选择了一个简化的词汇表，因为“ <em>synchizes-with</em> ”通常用于描述不同线程上的操作，而Go并未公开线程的概念。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你可以做任何类型的原子RMW操作</title>
      <link href="/cpu_parallel/you-can-do-any-kind-of-atomic-read-modify-write-operation.html"/>
      <url>/cpu_parallel/you-can-do-any-kind-of-atomic-read-modify-write-operation.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自：<a href="https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/" target="_blank" rel="noopener">https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/</a></p><p>略有删改</p></blockquote><p>原子读取-修改-写入操作（或称为“ RMW”）比<a href="http://preshing.com/20130618/atomic-vs-non-atomic-operations" target="_blank" rel="noopener">原子加载和存储</a>更为复杂。它们使您可以从共享内存中的变量读取数据，并同时在该变量中写入一个不同的值。在C ++ 11原子库中，以下所有功能均执行RMW：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;&gt;::fetch_add()</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;&gt;::fetch_sub()</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;&gt;::fetch_and()</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;&gt;::fetch_or()</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;&gt;::fetch_xor()</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;&gt;::exchange()</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;&gt;::compare_exchange_strong()</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;&gt;::compare_exchange_weak()</span><br></pre></td></tr></table></figure><p><code>fetch_add</code>例如，从一个共享变量中读取，为其添加另一个值，然后将结果写回–所有这些都是一个不可分割的步骤。您可以使用互斥锁完成相同的操作，但是基于互斥锁的版本并不是无锁的。另一方面，RMW操作被设计为无锁。他们将尽可能利用无锁CPU指令，例如ARMv7上的<code>ldrex</code>/ <code>strex</code>。</p><p>新手程序员可能会看上面的函数列表，然后问：“为什么C ++ 11提供的RMW操作这么少？为什么会有原子的<code>fetch_add</code>，但没有原子的<code>fetch_multiply</code>，没有<code>fetch_divide</code>又没有<code>fetch_shift_left</code>？” 有两个原因：</p><ol><li>因为在实践中几乎不需要这些RMW操作。尽量不要对RMW的使用方式有错误的印象。您不能通过采用单线程算法并将每个步骤转换为RMW来编写安全的多线程代码。</li><li>因为如果确实需要这些操作，则可以自己轻松实现它们。如标题所示，您可以进行任何类型的RMW操作！</li></ol><h2 id="比较交换：所有RMW的母亲"><a href="#比较交换：所有RMW的母亲" class="headerlink" title="比较交换：所有RMW的母亲"></a>比较交换：所有RMW的母亲</h2><p>在C ++ 11中所有可用的RMW操作中，唯一必不可少的是<code>compare_exchange_weak</code>。其他每个RMW操作都可以使用该操作来实现。至少需要两个参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared.compare_exchange_weak(T&amp; expected, T desired, ...);</span><br></pre></td></tr></table></figure><p>该函数尝试将<code>desired</code>值存储到<code>shared</code>，但仅当当前值<code>shared</code>匹配时才存储<code>expected</code>。<code>true</code>返回成功。如果失败，则将<code>shared</code>的当前值加载回<code>expected</code>中，尽管其名称为in/out参数。这称为<strong>比较交换</strong>操作，所有这些操作都在一个原子的不可分割的步骤中发生。</p><p><img src="/images/compare-exchange.png" alt="img"></p><p>因此，假设您确实需要原子<code>fetch_multiply</code>操作，尽管我无法想象为什么。这是实现它的一种方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> fetch_multiply(<span class="built_in">std</span>::atomic&lt;<span class="keyword">uint32_t</span>&gt;&amp; shared, <span class="keyword">uint32_t</span> multiplier)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> oldValue = shared.load();</span><br><span class="line">    <span class="comment">// PS: 这种情况可以使用shared.compare_exchange_strong(oldValue, oldValue * multiplier);</span></span><br><span class="line">    <span class="keyword">while</span> (!shared.compare_exchange_weak(oldValue, oldValue * multiplier))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这称为比较交换循环或<strong>CAS循环</strong>。该函数反复尝试<code>oldValue</code>与之交换<code>oldValue * multiplier</code>直到成功。如果在其他线程中未发生并发修改，<code>compare_exchange_weak</code>则通常会在第一次尝试时成功。另一方面，如果<code>shared</code>同时被另一个线程修改，则它的值完全有可能在对<code>load</code>调用和<code>compare_exchange_weak</code>调用之间改变，从而导致比较和交换操作失败。在这种情况下，<code>oldValue</code>将使用的最新值进行更新<code>shared</code>，然后循环将重试。</p><p><img src="/images/fetch-multiply-timeline.png" alt="img"></p><p>上述实现的<code>fetch_multiply</code>是原子操作也是无锁的。即使CAS循环可能需要不确定的尝试次数，它也是原子的，因为当循环最终修改<code>shared</code>时，它会自动进行。它是无锁的，因为如果CAS循环的单个迭代失败，通常是因为其他线程<code>shared</code>成功修改了。最后一条陈述基于这样的假设，即<code>compare_exchange_weak</code>实际上可以编译为无锁机器代码，更多内容将在下面进行。它还忽略了在某些平台上<code>compare_exchange_weak</code>可能<a href="http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange" target="_blank" rel="noopener">会虚假失败</a>的事实，但这是罕见的事件。</p><h2 id="您可以将多个步骤组合成一个RMW"><a href="#您可以将多个步骤组合成一个RMW" class="headerlink" title="您可以将多个步骤组合成一个RMW"></a>您可以将多个步骤组合成一个RMW</h2><p><code>fetch_multiply</code>只需将的值替换为<code>shared</code>相同值的倍数即可。如果我们想执行更复杂的RMW怎么办？我们还可以使操作原子化<em>和无</em>锁吗？我们当然可以。为此提供一个令人费解的示例，下面的函数加载一个共享变量，如果为奇数，则将值减小；如果为偶数，则将其除以一半；仅在大于或等于10的情况下，才将结果存储回去。所有这一切都在单个原子的、无锁操作中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> atomicDecrementOrHalveWithLimit(<span class="built_in">std</span>::atomic&lt;<span class="keyword">uint32_t</span>&gt;&amp; shared)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> oldValue = shared.load();</span><br><span class="line">    <span class="keyword">uint32_t</span> newValue;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldValue % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            newValue = oldValue - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            newValue = oldValue / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newValue &lt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!shared.compare_exchange_weak(oldValue, newValue));</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与以前的想法相同：如果<code>compare_exchange_weak</code>失败（通常是由于另一个线程执行的修改而导致的失败）<code>oldValue</code>被更新了最新的值，然后循环再次尝试。如果在任何尝试中发现<code>newValue</code>小于10，则CAS循环会提前终止，从而有效地将RMW操作变为无操作。</p><p>关键是您可以将任何内容放入CAS循环中。将CAS循环的主体视为关键部分。通常，我们使用互斥锁来保护关键部分。通过CAS循环，我们只需重试整个事务，直到成功为止。</p><p>这显然是一个综合的例子。<a href="https://github.com/preshing/cpp11-on-multicore/blob/master/common/autoresetevent.h" target="_blank" rel="noopener"><code>AutoResetEvent</code></a>在我<a href="http://preshing.com/20150316/semaphores-are-surprisingly-versatile" target="_blank" rel="noopener">较早的帖子中有关信号量</a>的课程中可以看到一个更实际的示例。它使用具有多个步骤的CAS循环以原子方式将共享变量增加到最大限制1。</p><h2 id="您可以将多个变量组合到一个RMW中"><a href="#您可以将多个变量组合到一个RMW中" class="headerlink" title="您可以将多个变量组合到一个RMW中"></a>您可以将多个变量组合到一个RMW中</h2><p>到目前为止，我们仅研究了对单个共享变量执行原子操作的示例。如果我们想对多个变量执行原子操作怎么办？通常，我们会使用互斥锁来保护这些变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="keyword">uint32_t</span> x;</span><br><span class="line"><span class="keyword">uint32_t</span> y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomicFibonacciStep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line">    <span class="keyword">int</span> t = y;</span><br><span class="line">    y = x + y;</span><br><span class="line">    x = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种基于互斥锁的方法是原子的，但显然不是无锁的。这<a href="http://preshing.com/20111118/locks-arent-slow-lock-contention-is" target="_blank" rel="noopener">可能已经足够好了</a>，但是为了说明起见，让我们继续将其转换为CAS循环，就像其他示例一样。<code>std::atomic&lt;&gt;</code>是一个模板，因此我们实际上可以将两个共享变量都打包到一个<code>struct</code>中，并像以前一样应用相同的模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Terms</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> x;</span><br><span class="line">    <span class="keyword">uint32_t</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Terms&gt; terms;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomicFibonacciStep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Terms oldTerms = terms.load();</span><br><span class="line">    Terms newTerms;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        newTerms.x = oldTerms.y;</span><br><span class="line">        newTerms.y = oldTerms.x + oldTerms.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!terms.compare_exchange_weak(oldTerms, newTerms));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此操作是否无锁？现在，我们正在冒险进入骰子领域。正如我在开始时所写的那样，C ++ 11原子操作的设计“尽可能”利用了无锁CPU指令，这是一个宽松的定义。在这种情况下，我们包装<code>std::atomic&lt;&gt;</code>了一个结构<code>Terms</code>。让我们看看GCC 4.9.2如何为x64编译它：</p><p><img src="/images/atomic-terms-rmw.png" alt="img"></p><p>我们很幸运。编译器非常聪明，它可以看到<code>Terms</code>适合单个64位寄存器，并<code>lock cmpxchg</code>使用来实现<code>compare_exchange_weak</code>。编译后的代码是无锁的。</p><p>这就提出了一个有趣的观点：通常，C ++ 11标准<em>不能</em>保证原子操作是无锁的。实在有太多的CPU体系结构无法支持，并且有太多的方法来专门化<code>std::atomic&lt;&gt;</code>模板。您需要<a href="http://en.cppreference.com/w/cpp/atomic/atomic/is_lock_free" target="_blank" rel="noopener">检查编译器</a>以确保绝对正确。但是，实际上，当满足以下所有条件时，可以假定原子操作是无锁的，这是非常安全的：</p><ol><li>编译器是MSVC，GCC或Clang的最新版本。</li><li>目标处理器是x86，x64或ARMv7（可能还有其他处理器）。</li><li>的原子类型是<code>std::atomic</code>，<code>std::atomic</code>或<code>std::atomic</code>对于一些类型<code>T</code>。</li></ol><p>作为个人喜好，我喜欢在第三点上挂上帽子，并限制自己使用显式整数或指针类型的特化<code>std::atomic&lt;&gt;</code>模板。我在上一篇文章中描述的<a href="http://preshing.com/20150324/safe-bitfields-in-cpp" target="_blank" rel="noopener">安全位域技术</a>为我们提供了一种使用显式整数特化<code>std::atomic</code>来重写上述函数的便捷方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BEGIN_BITFIELD_TYPE(Terms, <span class="keyword">uint64_t</span>)</span><br><span class="line">    ADD_BITFIELD_MEMBER(x, <span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line">    ADD_BITFIELD_MEMBER(y, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">END_BITFIELD_TYPE()</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; terms;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomicFibonacciStep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Terms oldTerms = terms.load();</span><br><span class="line">    Terms newTerms;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        newTerms.x = oldTerms.y;</span><br><span class="line">        newTerms.y = (<span class="keyword">uint32_t</span>) (oldTerms.x + oldTerms.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!terms.compare_exchange_weak(oldTerms, newTerms));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将几个值打包到原子位域中的一些实际示例包括：</p><ul><li>实现带标记的指针作为<a href="http://en.wikipedia.org/wiki/ABA_problem#Tagged_state_reference" target="_blank" rel="noopener">ABA问题</a>的<a href="http://en.wikipedia.org/wiki/ABA_problem#Tagged_state_reference" target="_blank" rel="noopener">解决方法</a>。</li><li>实现轻量级的读写锁，我在<a href="http://preshing.com/20150316/semaphores-are-surprisingly-versatile" target="_blank" rel="noopener">信号量惊人的通用</a>文章中曾简要介绍过。</li></ul><p>通常，只要您有少量数据受互斥锁保护，并且可以将数据完全打包为32位或64位整数类型，则始终可以将基于互斥锁的操作转换为无锁RMW操作，无论这些操作实际上是做什么的！这就是我在《<a href="http://preshing.com/20150316/semaphores-are-surprisingly-versatile" target="_blank" rel="noopener">信号量惊人的通用》</a>一文中采用的原理，以实现一堆轻量级的同步原语。</p><p>当然，这种技术并不是C ++ 11原子库所独有的。我仅使用C ++ 11原子，因为它们现在已经广泛使用，并且对编译器的支持非常好。您可以使用公开比较交换函数的任何库来实现自定义RMW操作，例如<a href="https://msdn.microsoft.com/en-us/library/ttk2z1ws.aspx" target="_blank" rel="noopener">Win32</a>，<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/OSAtomicCompareAndSwap32.3.html" target="_blank" rel="noopener">Mach内核API</a>，<a href="http://lxr.free-electrons.com/ident?i=atomic_cmpxchg" target="_blank" rel="noopener">Linux内核API</a>，<a href="https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/_005f_005fatomic-Builtins.html" target="_blank" rel="noopener">GCC原子内置</a><a href="http://lxr.free-electrons.com/ident?i=atomic_cmpxchg" target="_blank" rel="noopener">函数</a>或<a href="http://mintomic.github.io/lock-free/atomics/" target="_blank" rel="noopener">Mintomic</a>。为了简洁起见，在这篇文章中我没有讨论内存排序问题，但是考虑您的原子库所做的保证至关重要。特别是，如果您的自定义RMW操作旨在<strong>在线程之间传递非原子信息</strong>，那么至少应确保与<a href="http://preshing.com/20130823/the-synchronizes-with-relation" target="_blank" rel="noopener"><em>与</em></a>某处<a href="http://preshing.com/20130823/the-synchronizes-with-relation" target="_blank" rel="noopener"><em>同步</em></a>关系。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原子操作和非原子操作</title>
      <link href="/cpu_parallel/atomic-vs-non-atomic-operations.html"/>
      <url>/cpu_parallel/atomic-vs-non-atomic-operations.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自：<a href="https://preshing.com/20130618/atomic-vs-non-atomic-operations/" target="_blank" rel="noopener">https://preshing.com/20130618/atomic-vs-non-atomic-operations/</a></p><p>略有删改</p></blockquote><p>关于Web上原子操作的知识已经很多，通常集中在<a href="http://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation" target="_blank" rel="noopener">原子读-修改-写（RMW）</a>操作上。但是，这些并不是原子操作的唯一种类。还有原子加载和存储，它们同样重要。在这篇文章中，我将在处理器级别和C / C ++语言级别比较原子加载和存储与它们的非原子操作。在此过程中，我们将阐明C ++ 11的“数据竞争”概念。</p><p><img src="/images/nonatomic.png" alt="img"></p><p>如果共享内存相对于其他线程在单个步骤中完成，则该操作是<strong>原子的</strong>。在共享变量上执行原子存储时，没有其他线程可以观察到修改是半完成的。对共享变量执行原子加载时，它将读取单个时间点出现的<strong>整个值</strong>。非原子加载和存储不做那些保证。</p><p>没有这些保证，<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming" target="_blank" rel="noopener">无锁编程</a>将是不可能的，因为您永远无法让不同的线程同时操作共享变量。我们可以将其公式化为：</p><blockquote><p>每当两个线程同时对共享变量执行操作，并且其中一个操作执行写操作时，两个线程都<strong>必须</strong>使用原子操作。</p></blockquote><p>如果您违反了此规则，并且任一线程使用了非原子操作，那么您将拥有C ++ 11标准所指的<strong>数据竞争</strong>（不要与Java的数据竞争概念相混淆，或更一般的<a href="http://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">竞争条件</a>）。C ++ 11标准没有告诉您为什么数据竞争很糟糕。当您仅拥有一个时，才会导致“未定义的行为”（第<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf" target="_blank" rel="noopener">1.10.21节</a>）。此类数据竞争不佳的真正原因实际上很简单：它们导致读取和写入中断。</p><p>内存操作可能是非原子的，因为它使用了多个CPU指令，甚至在使用单个CPU指令时也有可能是非原子的，或许因为您正在编写可移植的代码，而根本无法做出某些操作是原子的假设。让我们看几个例子。</p><h2 id="由于多个CPU指令而导致非原子"><a href="#由于多个CPU指令而导致非原子" class="headerlink" title="由于多个CPU指令而导致非原子"></a>由于多个CPU指令而导致非原子</h2><p>假设您有一个64位的全局变量，初值为零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> sharedValue = <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p>在某个时候，您可以为该变量分配一个64位值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">storeValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sharedValue = <span class="number">0x100000002</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用GCC为32位x86平台编译此函数时，它将生成以下机器代码。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -O2 -S -masm=intel <span class="keyword">test</span>.c</span><br><span class="line">$ cat <span class="keyword">test</span>.s</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">mov</span><span class="built_in">DWORD</span> <span class="built_in">PTR</span> sharedValue, <span class="number">2</span></span><br><span class="line">        <span class="keyword">mov</span><span class="built_in">DWORD</span> <span class="built_in">PTR</span> sharedValue+<span class="number">4</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>如您所见，编译器使用两条单独的机器指令实现了64位分配。第一条指令将低32位设置为<code>0x00000002</code>，第二条指令将高32位设置为<code>0x00000001</code>。显然，此分配操作不是原子的。如果<code>sharedValue</code>被不同线程并发访问，则可能会出错：</p><ul><li>如果<code>storeValue</code>在两个机器指令之间抢占了一个线程调用，它将<code>0x0000000000000002</code>保留在内存中 – <strong>损坏的write</strong>。在这一点上，如果另一个线程读取<code>sharedValue</code>，它将收到这个完全错误的值。（PS：读错误）</li><li>更糟糕的是，如果在两个指令之间抢占了一个线程，而另一个线程<code>sharedValue</code>在第一个线程恢复之前进行了修改，则将导致永久性的写入中断：一个线程的高32位，另一个线程的低32位。（PS：写错误）</li><li>在多核设备上，甚至没有必要抢占其中一个线程来进行写入中断。当线程调用时<code>storeValue</code>，<code>sharedValue</code>在另一半内核上执行的任何线程都可以在只有一半更改可见的时候读取。（PS：此处并不是讨论私有缓存与全局内存不一致问题，因此已经限制在读写共享变量，此时讨论的是两个线程在两个核心上真正同时访问一个数据，数据一半的读写交错）</li></ul><p>并发读<code>sharedValue</code>会带来一系列问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> loadValue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> sharedValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ gcc -O2 -S -masm=intel test.c</span><br><span class="line">$ cat test.s</span><br><span class="line">        ...</span><br><span class="line">        moveax, DWORD PTR sharedValue</span><br><span class="line">        movedx, DWORD PTR sharedValue+<span class="number">4</span></span><br><span class="line">        ret</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>在这里，编译器也使用两条机器指令来实现装入操作：第一条将低32位读入<code>eax</code>，第二条将高32位读入<code>edx</code>。在这种情况下，如果<code>sharedValue</code>在两个指令之间可以看到并发存储，则即使并发存储是原子的，也会导致<strong>读取</strong>中断。</p><p>这些问题不仅仅是理论上的。<a href="http://mintomic.github.io/" target="_blank" rel="noopener">Mintomic</a>的测试套件包括一个称为的测试用例<code>test_load_store_64_fail</code>，其中一个线程使用普通分配运算符将一堆64位值存储到单个变量，而另一个线程从同一变量重复执行普通加载，从而验证每个结果。如预期的那样，在多核x86上，该测试始终失败。</p><p><img src="/images/load_store_x86.png" alt="img"></p><h2 id="非原子CPU指令"><a href="#非原子CPU指令" class="headerlink" title="非原子CPU指令"></a>非原子CPU指令</h2><p>即使通过单个CPU指令执行存储操作，也可以是非原子操作。例如，ARMv7指令集包括该<code>strd</code>指令，该指令将两个32位源寄存器的内容存储到内存中的单个64位值。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">strd </span><span class="built_in">r0</span>, <span class="built_in">r1</span>, [<span class="built_in">r2</span>]</span><br></pre></td></tr></table></figure><p>在某些ARMv7处理器上，该指令不是原子的。当处理器看到此指令时，实际上在<a href="http://web.eecs.umich.edu/~prabal/teaching/eecs373-f10/readings/ARMv7-M_ARM.pdf" target="_blank" rel="noopener">后台</a>执行了<em>两个<em>单独的32位存储（第<a href="http://web.eecs.umich.edu/~prabal/teaching/eecs373-f10/readings/ARMv7-M_ARM.pdf" target="_blank" rel="noopener">A3.5.3节</a>）。同样，在单独内核上运行的另一个线程可能会观察到写入中断。有趣的是，甚至在单核设备上也可能发生写入中断：实际上</em>，*在两个内部的32位存储器 *之间</em> 可能会发生系统中断（例如，计划的线程上下文切换）！在这种情况下，当线程从中断中恢复时，它将<code>strd</code>再次重新启动指令。</p><p>再举一个例子，众所周知，在x86上，<code>mov</code>如果内存操作数是自然对齐的，则32位指令是原子的，否则是非原子的。换句话说，仅当32位整数位于4的精确倍数的地址上时，原子性才得到<code>test_load_store_32_fail</code>保证。如本文所述，该测试始终在x86上成功，但是如果您修改测试以强制<code>sharedInt</code>使用某些未对齐的地址，它将失败。在我的Core 2 Quad Q6600上，<code>sharedInt</code>超过缓存行边界时测试失败：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制sharedInt越过缓存行边界：</span></span><br><span class="line"><span class="comment">// Force sharedInt to cross a cache line boundary:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line">MINT_DECL_ALIGNED(<span class="keyword">static</span> struct, <span class="number">64</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">62</span>];</span><br><span class="line">    <span class="keyword">mint_atomic32_t</span> sharedInt;</span><br><span class="line">&#125;</span><br><span class="line">g_wrapper;</span><br></pre></td></tr></table></figure><p><img src="/images/force_fail.png" alt="img"></p><p>到目前为止，这些信息已经足够了特定于处理器的细节。让我们在C / C ++语言级别上查看原子性。</p><h2 id="假定所有C-C-操作都是非原子的"><a href="#假定所有C-C-操作都是非原子的" class="headerlink" title="假定所有C / C ++操作都是非原子的"></a>假定所有C / C ++操作都是非原子的</h2><p>在C和C ++中，除非编译器或硬件供应商另行指定，否则所有操作都假定为非原子操作-甚至是纯32位整数分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> foo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">storeFoo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo = <span class="number">0x80286</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，语言标准没有明确指出是否是原子的。也许整数赋值是原子的，也许不是。由于非原子操作不做任何保证，因此按定义，C语言中的纯整数赋值是非原子的。</p><p>实际上，我们通常对目标平台了解更多。例如，众所周知，在所有现代x86，x64，Itanium，SPARC，ARM和PowerPC处理器上，只要目标变量自然对齐，纯32位整数分配<em>就是</em>原子的。您可以通过查阅处理器手册和/或编译器文档来进行验证。在游戏行业中，我可以告诉您，很多32位整数分配都依赖于此特定保证。</p><p>但是，在编写真正可移植的C和C ++时，有一个长期的传统，即我们假装除语言标准告诉我们的内容外，一无所知。可移植的C和C ++旨在：在过去、现在和未来的所有可能的计算设备上运行。就个人而言，我想像一台机器，只有先将其混合才能更改内存：</p><p><img src="/images/slot-machines.png" alt="img"></p><p>在这样的机器上，您绝对不希望与普通分配同时执行并发读取。您可能最终会读取完全随机的值。</p><p>在C ++ 11中，终于有了一种执行真正可移植的原子加载和存储的方法：C ++ 11原子库。使用C ++ 11原子库执行的原子加载和存储甚至可以在上述虚拟计算机上工作-即使这意味着C ++ 11原子库必须秘密锁定互斥体才能使每个操作原子化。还有我<a href="http://preshing.com/20130505/introducing-mintomic-a-small-portable-lock-free-api" target="_blank" rel="noopener">上个月发布</a>的<a href="http://mintomic.github.io/" target="_blank" rel="noopener">Mintomic</a>库，该库不支持那么多平台，但是可以在多个较旧的编译器上运行，经过手动优化，并且保证没有锁。</p><h2 id="松的原子操作"><a href="#松的原子操作" class="headerlink" title="松的原子操作"></a>松的原子操作</h2><p>让我们回到本文<code>sharedValue</code>前面的原始示例。我们将使用Mintomic对其进行重写，以便在Mintomic支持的每个平台上原子地执行所有操作。首先，我们必须将声明<code>sharedValue</code>为Mintomic的<a href="http://mintomic.github.io/lock-free/atomics/" target="_blank" rel="noopener">原子数据类型之一</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mintomic/mintomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mint_atomic64_t</span> sharedValue = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure><p>该<code>mint_atomic64_t</code>类型保证在每个平台上进行原子访问时都可以正确对齐内存。这很重要，因为例如，与Xcode 3.2.5捆绑在一起的用于ARM的GCC 4.2编译器不能保证朴素的<code>uint64_t</code>将以8字节对齐。</p><p>在<code>storeValue</code>中，我们必须调用<code>mint_store_64_relaxed</code>，而不是执行简单的非原子赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">storeValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mint_store_64_relaxed(&amp;sharedValue, <span class="number">0x100000002</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，在<code>loadValue</code>中，我们调用<code>mint_load_64_relaxed</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> loadValue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mint_load_64_relaxed(&amp;sharedValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用C ++ 11的术语，这些函数现在无数据竞争。并行执行时，无论代码是在ARMv6 / ARMv7（Thumb或ARM模式），x86，x64还是PowerPC上运行，读取或写入都绝对不会被破坏。<code>mint_load_64_relaxed</code>以及<code>mint_store_64_relaxed</code>这两个函数都可以扩展为<code>cmpxchg8b</code>x86上的内联指令。对于其他平台，请咨询Mintomic的<a href="https://github.com/mintomic/mintomic/tree/master/include/mintomic/private" target="_blank" rel="noopener">实现</a>。</p><p>这是用C ++ 11编写的完全相同的东西：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; sharedValue(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">storeValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sharedValue.store(<span class="number">0x100000002</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> loadValue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> sharedValue.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您会注意到，由<code>_relaxed</code>各种标识符的后缀证明，Mintomic和C ++ 11示例都使用了<code>relaxed</code>原子。该<code>_relaxed</code>后缀是一个提醒：几乎没有关于内存排列顺序的保证。</p><p>特别地，由于<a href="http://preshing.com/20120625/memory-ordering-at-compile-time" target="_blank" rel="noopener">编译器的重排列</a>或处理器自身的<a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations" target="_blank" rel="noopener">内存重排列</a>，将<code>relaxed</code>原子操作重排列在程序顺序之前或之后仍然是合法的。就像非原子操作一样，编译器甚至可以对冗余的<code>relaxed</code>原子操作执行优化。在所有情况下，该操作仍然是原子的。</p><p>当同时操作共享内存时，我认为最好始终使用Mintomic或C ++ 11原子库函数，即使在您知道目标平台上已经是原子加载或存储的情况下，也是如此。原子库函数提醒我们，在其他地方，此变量被并发访问。</p><p>希望现在已经更加清楚了，为什么<a href="http://preshing.com/20130605/the-worlds-simplest-lock-free-hash-table" target="_blank" rel="noopener">世界上最简单的无锁哈希表</a>使用Mintomic库函数来同时操作来自不同线程的共享内存。</p><p>PS：</p><h3 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h3><p>原子性不可能由软件单独保证–必须需要硬件的支持，因此是和架构相关的。<strong>在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段</strong>。CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀”LOCK”，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。</p><p>原子操作大部分使用汇编语言实现，因为C语言（或其它高级语言）并不能实现这样的操作。</p><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>在多线程访问共享资源时，能够确保所有其他的线程都不在同一时间内访问相同的资源。原子操作（atomic operation）是不需要<code>synchronized-with</code>的。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>acquire和release语意</title>
      <link href="/cpu_parallel/acquire_and_release_semantics.html"/>
      <url>/cpu_parallel/acquire_and_release_semantics.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自：<a href="https://preshing.com/20120913/acquire-and-release-semantics/" target="_blank" rel="noopener">https://preshing.com/20120913/acquire-and-release-semantics/</a></p><p>略有删改</p></blockquote><p>一般而言，在<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming" target="_blank" rel="noopener">无锁编程</a>中，线程可以通过两种方式操纵共享内存：</p><ol><li>相互竞争资源</li><li>将信息从一个线程传递到另一个线程。</li></ol><p>获取和释放语义对于后者至关重要：在线程之间可靠地传递信息。实际上，我敢冒险猜测不正确或丢失的获取和释放语义是无锁编程错误的第一类型。</p><p>在本文中，我将演示在C ++中实现获取和释放语义的各种方法。我将以介绍性的方式介绍C ++ 11 <code>atomic</code>库标准，因此您无需了解它。从一开始就很清楚，这里的信息适用于<em>没有</em> <a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming#sequential-consistency" target="_blank" rel="noopener">顺序一致性的</a><em>无</em>锁编程。我们直接在多核或多处理器环境中处理内存排序。</p><p>不幸的是，术语 <em>acquire and release semantics</em> 似乎比术语 <em>lock-free</em> 更乱，因为您搜索网络的次数越多，您会发现看似矛盾的定义。布鲁斯·道森（Bruce Dawson）在本<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ee418650.aspx" target="_blank" rel="noopener">白皮书</a>的一半左右位置提供了两个很好的定义（归功于Herb Sutter）。我想提供一些我自己的定义，以接近C ++ 11 <code>atomic</code>背后的原理：</p><blockquote><p><img src="/images/read-acquire.png" alt="img"></p><p><strong>获取语义</strong>是仅适用于从共享内存<strong>读取</strong>的操作的属性，无论它们是<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming#atomic-rmw" target="_blank" rel="noopener">读-修改-写</a>操作还是普通加载。然后将该操作视为<strong>已读取</strong>。获取语义防止在它<strong>之后</strong>的任何读写操作的内存重新排序到<em>read-acquire</em>的前面。</p></blockquote><blockquote><p><img src="/images/write-release.png" alt="img"></p><p><strong>释放语义</strong>是仅适用于<strong>写入</strong>共享内存的操作的属性，无论它们是读-修改-写操作还是普通存储。然后将该操作视为<strong>已写入</strong>。释放语义防止在它<strong>之前</strong>的任何读写操作的内存重新排列到write-release的后面。</p></blockquote><p>一旦理解了上面的定义，就不难发现使用我<a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations" target="_blank" rel="noopener">在上一篇文章中详细描述</a>的内存屏障类型的简单组合就可以实现获取和释放语义。必须（以某种方式）将屏障放置在读获取操作之后，但在写入释放之前。<em>[更新：请注意，在单个内存操作的技术上，这些屏障比获取和释放语义所要求的更为严格，但它们确实达到了预期的效果。]</em></p><p><img src="/images/acq-rel-barriers.png" alt="img"></p><p>很棒的是获取或释放语义都不需要使用<code>#StoreLoad</code>屏障，这个屏障通常是更昂贵的内存屏障类型。例如，在PowerPC，所述<code>lwsync</code>（简称“轻量同步”）指令同时扮演<code>#LoadLoad</code>，<code>#LoadStore</code>和<code>#StoreStore</code>三个障碍的角色，比包含<code>#StoreLoad</code>屏障的<code>sync</code>指令更轻量。</p><h2 id="显示使用平台相关的屏障"><a href="#显示使用平台相关的屏障" class="headerlink" title="显示使用平台相关的屏障"></a>显示使用平台相关的屏障</h2><p>获得期望的内存屏障的一种方法是发出明确的屏障指令。让我们从一个简单的例子开始。假设我们正在为PowerPC进行编码，并且<code>__lwsync()</code>是发出<code>lwsync</code>指令的编译器固有函数。由于<code>lwsync</code>提供了许多屏障类型，因此我们可以在以下代码中使用它来根据需要建立获取或释放语义。在线程1中，存储<code>Ready</code>变为写释放，而在线程2中，来自的负载<code>Ready</code>变为读取获取。</p><p><img src="/images/platform-fences.png" alt="img"></p><p>如果我们让两个线程都运行，并找到<code>r1 == 1</code>，则可以确认在线程1中赋给A的值已成功传递给线程2。因此，我们可以保证<code>r2 == 42</code>。在我以前的帖子，我已经<a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations" target="_blank" rel="noopener">给了一个漫长的比喻</a>为说明<code>#LoadLoad</code>和<code>#StoreStore</code>如何工作的，所以我不会在这里老调重弹这个解释。</p><p>用正式的术语来说，我们说<code>Ready</code> 的存储<em>与</em> 加载<em>同步<em>。另外，我在<a href="http://preshing.com/20130823/the-synchronizes-with-relation" target="_blank" rel="noopener">此处</a>单独写了一篇关于</em>synchronizes-with</em> 的文章 。到目前为止，足以说这种技术正常工作，获取和释放语义必须应用于同一变量。在这个例子中，<code>Ready</code>和存储和加载必须都是原子操作。这里<code>Ready</code>与<code>int</code>简单对齐 ，操作在PowerPC上已经是原子的。</p><h2 id="在可移植C-11中使用屏障"><a href="#在可移植C-11中使用屏障" class="headerlink" title="在可移植C ++ 11中使用屏障"></a>在可移植C ++ 11中使用屏障</h2><p>上面的示例是特定于编译器和处理器的。支持多种平台的一种方法是将代码转换为C ++ 11。所有C ++ 11标识符都存在于<code>std</code>名称空间中，因此，为了使下面的示例简短，让我们假设该语句<code>using namespace std;</code>位于代码的较早位置。</p><p>C ++ 11的原子库标准定义了一个可移植函数<code>atomic_thread_fence()</code>，该函数采用单个参数来指定屏障的类型。该参数有几个可能的值，但是我们在这里最感兴趣的值是<code>memory_order_acquire</code>和<code>memory_order_release</code>。我们将使用此功能代替<code>__lwsync()</code>。</p><p>在此示例完成之前，还需要进行其他更改。在PowerPC上，我们知道这两个操作<code>Ready</code>都是原子的，但是我们不能对每个平台都做此假设。为了确保所有平台上的原子性，我们将把<code>Ready</code>的类型从<code>int</code>更改为<code>atomic</code>。我知道，如果考虑对齐的<code>int</code>的加载和存储在当今存在的每个现代CPU上都是原子的，这是一个愚蠢的改变。我将在<a href="http://preshing.com/20130823/the-synchronizes-with-relation" target="_blank" rel="noopener"><em>synchronize-with</em></a>的帖子中写更多有关此的内容，但是现在，让我们为理论上100％正确的热情做此事。无需更改<code>A</code>。</p><p><img src="/images/cpp11-fences.png" alt="img"></p><p>上面的<code>memory_order_relaxed</code>意味着“确保这些操作是原子的，但不要强加尚不存在的任何排序约束/内存障碍。”</p><p>再一次，上述两个<code>atomic_thread_fence()</code>调用在PowerPC上都可以使用<code>lwsync</code>实现。同样，在ARM上它们都可以使用<code>dmb</code>指令实现，我认为它至少与PowerPC的<code>lwsync</code>一样有效。在x86/64上，两个<code>atomic_thread_fence()</code>调用都可以简单地实现为<a href="http://preshing.com/20120625/memory-ordering-at-compile-time" target="_blank" rel="noopener">编译器障碍</a>，因为通常x86/64上的每个加载都已经隐含了获取语义，每个存储都隐含了释放语义。这就是为什么x86/64通常被认为是<a href="http://preshing.com/20120930/weak-vs-strong-memory-models" target="_blank" rel="noopener">有序的原因</a>。</p><h2 id="在可移植C-11中不直接使用屏障"><a href="#在可移植C-11中不直接使用屏障" class="headerlink" title="在可移植C ++ 11中不直接使用屏障"></a>在可移植C ++ 11中不直接使用屏障</h2><p>在C ++ 11中，<code>Ready</code>无需发出显式的屏障指令就可以实现获取和释放语义。您只需要在以下操作上直接指定内存排序约束<code>Ready</code>：</p><p><img src="/images/cpp11-no-fences.png" alt="img"></p><p>可以将其视为将每个屏障指令滚动到<code>Ready</code>自己的操作中。*[更新：请注意，此表格与使用<a href="http://preshing.com/20131125/acquire-and-release-fences-dont-work-the-way-youd-expect" target="_blank" rel="noopener">独立屏障的版本</a>不完全相同；从技术上讲，它不太严格。]<em>编译器将发出任何必需的指令，以获得所需的屏障效果。特别是在Itanium上，每个操作都可以轻松实现为一条指令：<code>ld.acq</code>和<code>st.rel</code>。与以前一样，<code>r1 == 1</code>表示一个</em>synchronizes-with*关系，确认<code>r2 == 42</code>是对的。</p><p>实际上，这是在C ++ 11中表达获取和释放语义的首选方法。实际上，<code>atomic_thread_fence()</code>在上一示例中使用的功能是在标准创建的<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2633.html" target="_blank" rel="noopener">后期</a>才添加的。</p><h2 id="使用锁实现获取释放语义"><a href="#使用锁实现获取释放语义" class="headerlink" title="使用锁实现获取释放语义"></a>使用锁实现获取释放语义</h2><p>如您所见，本文中的所有示例均未利用获取和释放语义所提供的<code>#LoadStore</code>屏障。确实，只需要<code>#LoadLoad</code>和<code>#StoreStore</code>。这仅仅是因为在本文中，我选择了一个简单的示例让我们专注于API和语法。</p><p><code>#LoadStore</code>变得很重要的一种情况是，使用获取和释放语义来实现(互斥)锁。实际上，这就是获取与释放语义名称的来源：获取锁意味着获取语义，而释放锁则意味着释放语义！介于两者之间的所有内存操作都包含在一个漂亮的小屏障夹中，以防止任何不希望的内存跨越边界重新排序。</p><p><img src="/images/acq-rel-lock.png" alt="img"></p><p>在这里，获取和释放语义可确保在持有锁的同时进行的所有修改将完全传播到获取锁的下一个线程。锁的每种实现，即使<a href="http://preshing.com/20120226/roll-your-own-lightweight-mutex" target="_blank" rel="noopener">您自己的实现</a>，也应提供这些保证。同样，这都是为在线程之间可靠地传递信息，尤其是在多核或多处理器环境中。</p><p>PS：不论何种方式实现获取和释放语义，底层都是借助处理器或编译器的内存屏障指令来完成。语言层次提供的获取释放语义只是对底层指令的封装。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取和释放屏障</title>
      <link href="/cpu_parallel/acquire_fence_and_release_fence.html"/>
      <url>/cpu_parallel/acquire_fence_and_release_fence.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自：<a href="https://preshing.com/20130922/acquire-and-release-fences/" target="_blank" rel="noopener">https://preshing.com/20130922/acquire-and-release-fences/</a></p></blockquote><p>我认为，获取(<strong>acquire fence</strong>, afence)和释放屏障(<strong>release fence</strong>, rfence)目前在网络上还是被误解了。太糟糕了，因为C ++ 11标准委员会在指明这些内存保屏障的含义方面做得很好。它们提供了强大的算法，可以在多个内核之间很好地扩展，并且可以很好地映射到当今最常见的CPU架构上。</p><p>首先，第一件事：获取和释放屏障被认为是<em>低级别的无锁操作</em>。如果您坚持使用更高级别的，<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming#sequential-consistency" target="_blank" rel="noopener">顺序一致的</a>原子类型（例如<code>volatile</code>Java 5+中的变量或C ++ 11中的默认原子），则不需要获取和释放屏障。折衷是顺序一致类型对于某些算法来说可扩展性或性能稍差。</p><p>另一方面，如果您是在C ++ 11发布前为多核设备开发的，则您可能会对获取和释放屏障感兴趣。也许像我一样，您还记得<code>lwsync</code>在Xbox 360上同步线程时在一些内部函数的放置上遇到了麻烦。最酷的是，一旦您了解了获取和释放屏障，您实际上就会看到我们一直在尝试使用这些特定于平台的屏障来完成的工作。</p><p>您可能会想到，获取和释放屏障是独立的内存屏障，这意味着它们没有与任何特定的内存操作耦合。那么，它们如何工作？</p><blockquote><p>一个<strong>afence</strong>，防止在其之前的任何<strong>读操作</strong>内存重排序到其之后的任何<strong>读写操作</strong>中。</p><p><em>An</em> <strong>acquire fence</strong> <em>prevents the memory reordering of any</em> <strong>read</strong> <em>which precedes it in program order with any</em> <strong>read or write</strong> <em>which follows it in program order.</em></p></blockquote><blockquote><p>一个<strong>rfence</strong>，防止在其之后的任何<strong>读写操作</strong>内存重排序到其之前的任何<strong>写操作</strong>中。</p><p><em>A</em> <strong>release fence</strong> <em>prevents the memory reordering of any</em> <strong>read or write</strong> <em>which precedes it in program order with any</em> <strong>write</strong> <em>which follows it in program order.</em></p></blockquote><p>换句话说，就<a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations" target="_blank" rel="noopener">此处说明</a>的屏障类型而言，获取屏障用作<code>#LoadLoad</code>+ <code>#LoadStore</code>屏障，而释放屏障用作<code>#LoadStore</code>+ <code>#StoreStore</code>屏障。他们声称要做的就是这些。</p><p><img src="/images/barrier-types-fence.png" alt="img"></p><p>使用C ++ 11进行编程时，可以使用以下函数调用它们：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line"><span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);</span><br></pre></td></tr></table></figure><p>在C11中，他们采用以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line">atomic_thread_fence(memory_order_acquire);</span><br><span class="line">atomic_thread_fence(memory_order_release);</span><br></pre></td></tr></table></figure><p>并使用<a href="http://mintomic.github.io/lock-free/memory-fences/" target="_blank" rel="noopener">Mintomic</a>（一个小型的、可移植的无锁API）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mintomic/mintomic.h&gt;</span></span></span><br><span class="line">mint_thread_fence_acquire();</span><br><span class="line">mint_thread_fence_release();</span><br></pre></td></tr></table></figure><p>在SPARC-V9架构上，可以使用<code>membar #LoadLoad | #LoadStore</code>指令实现获取隔离，而发布隔离可以实现为<code>membar #LoadStore | #StoreStore</code>。在其他CPU体系结构上，实现上述库的人员必须将这些操作转换为次要的事情-某些CPU指令<em>至少</em>提供所需的屏障类型，甚至可能更多。在PowerPC上，第二件事是<code>lwsync</code>。在ARMv7上，第二件事是<code>dmb</code>。在Itanium上，第二好是<code>mf</code>。在x86 / 64上，<a href="http://preshing.com/20120930/weak-vs-strong-memory-models" target="_blank" rel="noopener">根本不需要CPU指令</a>。如您所料，获取和释放围墙也会<a href="http://preshing.com/20120625/memory-ordering-at-compile-time" target="_blank" rel="noopener">在编译时</a>限制相邻操作的重新排序。</p><h2 id="他们可以建立同步关系"><a href="#他们可以建立同步关系" class="headerlink" title="他们可以建立同步关系"></a>他们可以建立<em>同步</em>关系</h2><p>有关获取和释放屏障的最重要信息是，它们可以建立<a href="http://preshing.com/20130823/the-synchronizes-with-relation" target="_blank" rel="noopener"><em>同步</em></a>关系，这意味着它们以允许您在线程之间可靠地传递信息的方式禁止内存重新排序。请记住，如下图所示，获取和释放屏障只是可以建立<em>同步</em>关系的众多构造之一。</p><p><img src="/images/org-chart-fences.png" alt="img"></p><p>正如我之前所<a href="http://preshing.com/20120913/acquire-and-release-semantics" target="_blank" rel="noopener">展示的</a>，紧随<code>afence</code>后的一个relaxed 加载原子操作将把加载转成<code>read-acquire</code>。类似地，紧随<code>rfence</code>之前的relaxed 存储原子操作将把该存储转换为<code>write-release</code>。例如，如果<code>g_guard</code>具有type <code>std::atomic</code>，则此行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_guard.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br></pre></td></tr></table></figure><p>可以安全地替换为以下内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">g_guard.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br></pre></td></tr></table></figure><p>一种精度：在后一种形式中，存储不再<em>与</em>任何东西<em>同步</em>。它是栅栏本身。要了解我的意思，让我们来看一个详细的示例。</p><h2 id="使用获取和释放屏障的演练"><a href="#使用获取和释放屏障的演练" class="headerlink" title="使用获取和释放屏障的演练"></a>使用获取和释放屏障的演练</h2><p>我们将以我<a href="http://preshing.com/20130823/the-synchronizes-with-relation/" target="_blank" rel="noopener">以前的帖子中</a>的示例为例，并对其进行修改以使用C ++ 11的独立获取和发布屏障。这是<code>SendTestMessage</code>函数。现在原子写入是<code>relaxed</code>，并且释放栅栏已紧接其放置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendTestMessage</span><span class="params">(<span class="keyword">void</span>* param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Copy to shared memory using non-atomic stores.</span></span><br><span class="line">    g_payload.tick  = clock();</span><br><span class="line">    g_payload.str   = <span class="string">"TestMessage"</span>;</span><br><span class="line">    g_payload.param = param;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Release fence.</span></span><br><span class="line">    <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform an atomic write to indicate that the message is ready.</span></span><br><span class="line">    g_guard.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是<code>TryReceiveMessage</code>函数。原子读取是<code>relaxed</code>，并且获取栅栏已稍稍置于其后。在这种情况下，在读取后不会<em>立即</em>出现屏障。我们首先检查是否为<code>ready != 0</code>，因为这是真正需要屏障的唯一情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryReceiveMessage</span><span class="params">(Message&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Perform an atomic read to check whether the message is ready.</span></span><br><span class="line">    <span class="keyword">int</span> ready = g_guard.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ready != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Acquire fence.</span></span><br><span class="line">        <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Yes. Copy from shared memory using non-atomic loads.</span></span><br><span class="line">        result.tick  = g_payload.tick;</span><br><span class="line">        result.str   = g_payload.str;</span><br><span class="line">        result.param = g_payload.param;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// No.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果<code>TryReceiveMessage</code>碰巧看到<code>SendTestMessage</code>在<code>g_guard</code>上执行了写操作，那么它将发出获取屏障，并且<em>同步</em>关系已完成。同样，严格来说，是屏障彼此<em>同步</em>。</p><p><img src="/images/two-cones-fences.png" alt="img"></p><p>让我们备份一会儿，并根据我前一段时间进行的<a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations" target="_blank" rel="noopener">源代码控制类比</a>考虑此示例。想象一下共享内存是一个中央存储库，每个线程都有该存储库的专用副本。当每个线程操纵其私有副本时，修改会在不可预知的时间不断地“往返”中央存储库。获取和释放屏障用于在这些泄漏之间强制排序。</p><p><img src="/images/source-control-fences.png" alt="img"></p><p>如果我们将线程1想象为名为拉里的程序员，并将线程2想象为名为谢尔盖的程序员，则会发生以下情况：</p><ol><li>拉里对他的私人副本执行了许多非原子存储<code>g_payload</code>。</li><li>拉里发行了释放栅栏。这意味着他之前所有的内存操作（无论何时发生）都将提交到存储库中，<em>然后再</em>执行下一个存储。PS：git push</li><li>拉里将<code>1</code>放入了自己的<code>g_guard</code>私有副本中。</li><li>此后的某个随机时刻，拉里的<code>g_guard</code>副本push到中央存储库，完全由<code>g_guard</code>自己决定何时push自己。请记住，一旦发生这种情况，我们就可以保证Larry对的更改<code>g_payload</code>也位于中央存储库中。PS：虽然可能不是很及时，但我们一定很自信<code>g_payload</code>的修改一定发生完成了。</li><li>此后的某个随机时刻，更新的<code>g_guard</code>从中央存储库leak到谢尔盖的私有副本中，何时leak，完全由<code>g_guard</code>决定。</li><li>谢尔盖检查他的私人副本<code>g_guard</code>并看到<code>1</code>。</li><li>看到这一点，谢尔盖发出了获取围栏。谢尔盖的私人副本的所有内容<em>至少</em>与以前的加载一样新。这样就完成了<em>同步</em>关系。</li><li>谢尔盖从他的<code>g_payload</code>私有副本中执行了一堆非原子加载。在这一点上，他可以保证看到拉里编写的值。</li></ol><p>请注意，guard变量必须自己从拉里的私有工作区“泄漏”到谢尔盖。当您考虑时，获取和释放防屏障只是在此类泄漏之上附带其他数据的一种方法。</p><h2 id="C-11标准得到了支持"><a href="#C-11标准得到了支持" class="headerlink" title="C ++ 11标准得到了支持"></a>C ++ 11标准得到了支持</h2><p>C ++ 11标准明确声明此示例将在库和语言的任何兼容实现品上工作。在<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf" target="_blank" rel="noopener">工作草案N3337</a> 的第29.8.2节中做出了承诺：</p><blockquote><p>如果存在对某个原子对象M进行操作的原子操作X和Y，则释放屏障A <strong>与</strong>获取屏障B <strong>同步</strong>，这样A排序在X之前，X修改M，Y排序在B之前，并且Y读取由X写入的值或由假设的释放序列X中的任何副作用写入的值都会出现，如果它是一个release操作。</p><p><em>A release fence A</em> <strong>synchronizes with</strong> <em>an acquire fence B if there exist atomic operations X and Y, both operating on some atomic object M, such that A is sequenced before X, X modifies M, Y is sequenced before B, and Y reads the value written by X or a value written by any side effect in the hypothetical release sequence X would head if it were a release operation.</em></p></blockquote><p>有很多字母。让我们分解一下。在上面的示例中：</p><ul><li><em>释放防屏障A</em>是出现在<code>SendTestMessage</code>中的释放屏障。</li><li><em>原子操作X</em>是执行在<code>SendTestMessage</code>中的relaxed存储原子操作。</li><li><em>原子对象M</em>是保护变量<code>g_guard</code>。</li><li><em>原子操作Y</em>是执行在<code>TryReceiveMessage</code>中的relaxed加载原子操作。</li><li><em>获取栅栏B</em>是出现在<code>TryReceiveMessage</code>中的获取屏障。</li></ul><p>最后，<em>如果</em>relaxed原子加载读取了relaxed原子存储写入的值，则C ++ 11标准将指出，正如我所展示的，屏障彼此<em>同步</em>。</p><p>我喜欢C ++ 11的可移植的内存屏障方法。过去，其他人曾尝试设计可移植的内存屏障API，但就我个人而言，就独立的屏障而言，很少有人碰到像C ++ 11这样的无锁编程的甜蜜。尽管获取和发布屏障可能无法直接转换为本机CPU指令，但它们足够接近，您仍然可以从绝大多数多核设备中获得当前可能的最高性能。这就是为什么我在今年早些时候发布的Mintomic（一个开放源代码库）提供<a href="http://mintomic.github.io/lock-free/memory-fences/" target="_blank" rel="noopener">获取和发布屏障</a>以及消耗和完整内存隔离区作为其唯一的<code>内存顺序</code>操作的原因。<a href="https://gist.github.com/preshing/6663087" target="_blank" rel="noopener">这是</a>本文中使用Mintomic重写的示例。</p><p>在即将发布的帖子中，我将重点介绍一些当前漂浮在网络上的有关获取和发布屏障的误解，并讨论一些性能问题。我还将进一步讨论它们与<code>read-acquire</code> 和<code>write-release</code>的关系，包括这种关系的一些后果，这些后果往往会使人们绊倒。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存屏障就像源码控制操作一样</title>
      <link href="/cpu_parallel/memory_fence.html"/>
      <url>/cpu_parallel/memory_fence.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>翻译自：<a href="https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/" target="_blank" rel="noopener">https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/</a></p><p>略有修改</p></blockquote><p>如果使用源代码控制，那么您将逐渐理解内存顺序，这是使用C，C ++和其他语言编写无锁代码时的重要考虑因素。<em>[PS：内存顺序真的很重要，问题不仅仅来源于CPU的多层次存储系统，事实上这个问题在处理器层次已经比较好的解决了。假如只有共享内存，更容易看出真正的问题是：多线程环境下数据对象的败坏。我们所有的努力都是为了数据对象的同步，也就是对读写次序的控制。]</em></p><p>在上一篇文章中，我写了关于<a href="http://preshing.com/20120625/memory-ordering-at-compile-time" target="_blank" rel="noopener">编译期时内存排序</a>，它构成了内存排序难题的一半。这篇文章是关于另一半的：运行时的内存排序，在处理器本身上。*[PS：也就是处理器执行时的指令排序，由处理器决定]*像编译器重新排序一样，处理器重新排序对于单线程程序是不可见的。仅当使用<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming" target="_blank" rel="noopener">无锁技术</a>时，即在没有线程之间相互排斥的情况下操作共享内存时，这种情况才变得明显。但是，与编译器重新排序不同，处理器重新排序的效果<a href="http://preshing.com/20120515/memory-reordering-caught-in-the-act" target="_blank" rel="noopener">仅在多核和多处理器系统中可见</a>。</p><p>您可以通过发出任何充当<strong>内存屏障</strong>的指令来在处理器上强制执行正确的内存排序。在某些方面，这是您唯一需要知道的技术，因为当您使用这些指令时，编译器的排序会自动执行。用作内存屏障的指令示例包括（但不限于）以下内容：</p><ul><li>GCC中的某些内联汇编指令，例如PowerPC特定的 <code>asm volatile(&quot;lwsync&quot; ::: &quot;memory&quot;)</code></li><li>任何<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684122.aspx" target="_blank" rel="noopener">Win32互锁操作</a>，Xbox 360除外</li><li>对<a href="http://en.cppreference.com/w/cpp/atomic/atomic" target="_blank" rel="noopener">C ++ 11原子类型</a>的许多操作，例如<code>load(std::memory_order_acquire)</code></li><li>POSIX互斥锁上的操作，例如 <a href="http://linux.die.net/man/3/pthread_mutex_lock" target="_blank" rel="noopener"><code>pthread_mutex_lock</code></a></li></ul><p>就像有许多指令充当内存屏障一样，也有许多不同类型的内存屏障需要了解。确实，并非所有上述指令都会产生相同类型的内存障碍 - 导致在编写无锁代码时出现另一个可能的混乱地方。为了在某种程度上解决问题，我想提供一个类比，它有助于理解绝大多数（但不是全部）可能的内存屏障类型。</p><p>首先，请考虑典型的多核系统的体系结构。这是一个具有两个内核的设备，每个内核具有32 KiB的私有L1数据缓存。两个内核之间共享1 MiB的L2高速缓存，以及512 MiB的主内存。</p><p><img src="/images/cpu-diagram.png" alt="img"></p><p>多核系统有点像一群程序员使用一种奇怪的源代码控制策略在一个项目上进行协作。例如，上述双核系统对应于只有两个程序员的情况。我们命名为拉里和谢盖尔。</p><p><img src="/images/source-control-analogy.png" alt="img"></p><p>在右侧，我们有一个共享的中央存储库–它表示主内存和共享的L2缓存的组合。拉里在他的本地计算机上拥有该存储库的完整工作副本，谢盖尔也是如此 – 这些（有效地）代表了附加到每个CPU内核的L1缓存。每台机器上都有一个暂存区，用于私下跟踪寄存器和/或局部变量。我们的两个程序员坐在那里，狂热地编辑他们的工作副本和暂存区，同时根据所看到的数据来决定下一步的工作-就像在该内核上运行的执行线程一样。</p><p>这将我们带到了源代码控制策略。以此类推，源代码控制策略确实非常奇怪。当拉里和谢盖尔修改其存储库的工作副本时，他们的修改总是在完全随机的时间在后台向中央存储库和从中央存储库<strong>泄漏</strong>。一旦拉里编辑了文件X，他的更改将泄漏到中央存储库，但不能保证何时发生。它可能会立即发生，也可能会在很多以后发生。他可能会继续编辑其他文件，例如Y和Z，并且这些修改可能会<em>在</em> X泄漏<em>之前</em>泄漏到存储库中。通过这种方式，可以有效地将存储重新排序到存储库。</p><p>同样，谢尔盖的机器上，没有关于这些变化在后台向中央存储库和从中央存储库<strong>泄漏</strong>的时间和顺序保证。通过这种方式，加载将高效地以它的方式重新排序。</p><p>现在，如果每个程序员都在存储库的完全独立的部分上工作，那么任何一个程序员都不会知道这些正在进行的背后泄漏，甚至都不知道另一个程序员的存在。这类似于运行两个独立的单线程进程。在这种情况下，将<a href="http://preshing.com/20120625/memory-ordering-at-compile-time" target="_blank" rel="noopener">保持内存排序的基本规则</a>。</p><p>一旦我们的程序员开始处理存储库的相同部分，该类比就变得更加有用。让我们回顾一下我<a href="http://preshing.com/20120515/memory-reordering-caught-in-the-act" target="_blank" rel="noopener">在较早的文章中</a>给出的示例。X和Y是全局变量，都初始为0：</p><p><img src="/images/marked-example2-2.png" alt="img"></p><p>将X和Y视为存在于拉里存储库的工作副本，谢盖尔的工作副本以及中央存储库本身上的文件。拉里在其工作副本X中写入1，而几乎同时谢尔盖在其工作副本Y中写入1。如果两个修改都没有时间泄漏到存储库中，然后又在每个程序员查找<em>另一个</em>文件的工作副本之前返回，则最终它们都将以r1 = 0和r2 = 0结束。实际上在源代码控制类比中变得很明显。</p><p><img src="/images/iriw-state.png" alt="img"></p><h2 id="内存屏障的类型"><a href="#内存屏障的类型" class="headerlink" title="内存屏障的类型"></a>内存屏障的类型</h2><p>幸运的是，拉里和谢盖尔并不完全受后台发生的这些随机的、不可预测的泄漏的影响。它们还具有发出特殊指令的能力，称为屏障( <em>fence</em> )指令，扮演内存屏障角色。对于这个比喻，定义四种类型的内存屏障就足够了，因此定义了四种不同的屏障指令就足够了。每种类型的内存屏障均以其，旨在防止的内存重新排序类型来命名：例如，<code>#StoreLoad</code>旨在防止存储紧随加载后的重新排序。</p><p><img src="/images/barrier-types.png" alt="img"></p><p>正如<a href="http://g.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">Doug Lea指出的那样</a>，这四个类别可以很好地映射到真实CPU上的特定指令，尽管不完全相同。在大多数情况下，实际的CPU指令可能是上述屏障类型的某种组合，可能还有其他影响。无论如何，一旦您理解了这四种类型的内存障碍在源代码控制类比中，就可以很好地了解它们在真实CPU上的大量指令以及几种高级编程语言构造。</p><h3 id="LoadLoad"><a href="#LoadLoad" class="headerlink" title="#LoadLoad"></a>#LoadLoad</h3><p>LoadLoad屏障有效地防止了在屏障之前执行的加载和在屏障之后执行的加载之间的重排列。</p><p>以我们的类比，<code>#LoadLoad</code>fence指令基本上等效于从中央存储库中<strong>pull</strong>信息。想想<code>git pull</code>，<code>hg pull</code>，<code>p4 sync</code>，<code>svn update</code>或者<code>cvs update</code>对整个存储库的作用。如果与他的本地更改存在任何合并冲突，我们可以说它们是随机解决的。</p><p><img src="/images/loadload.png" alt="img"></p><p>提醒您，我们无法保证<code>#LoadLoad</code>会<code>pull</code>整个存储库的最新修订版本！ 可能拉取到比head更旧的修订版，只要修订版至少与从中央仓库泄漏到本地机器的最新值一样新就行。</p><p>这听起来像是一个薄弱的保证，但它仍然是防止看到陈旧数据的绝妙方法。考虑一下经典示例，其中谢盖尔检查一个共享标志，以查看拉里是否已发布某些数据。如果该标志为真，则<code>#LoadLoad</code>在读取发布的值之前，他将发布一个屏障：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsPublished)                   <span class="comment">// Load and check shared flag</span></span><br><span class="line">&#123;</span><br><span class="line">    LOADLOAD_FENCE();              <span class="comment">// Prevent reordering of loads</span></span><br><span class="line">    <span class="keyword">return</span> Value;                  <span class="comment">// Load published value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，此示例取决于<code>IsPublished</code>标志本身是否泄漏到谢盖尔的工作副本中。何时发生并不重要。一旦观察到泄漏的标志，他就会发出<code>#LoadLoad</code>屏障以防止读取<code>Value</code>比标志本身还旧的值。</p><h3 id="StoreStore"><a href="#StoreStore" class="headerlink" title="#StoreStore"></a>#StoreStore</h3><p>StoreStore屏障有效地防止了在屏障之前执行的存储与屏障之后执行的存储的重新排序。</p><p>以我们的比喻，<code>#StoreStore</code>fence指令对应于对中央存储库的<strong>push</strong>。想想<code>git push</code>，<code>hg push</code>，<code>p4 submit</code>，<code>svn commit</code>或者<code>cvs commit</code>，对整个存储库的作用。</p><p><img src="/images/storestore.png" alt="img"></p><p>另外，让我们假设<code>#StoreStore</code>指令<strong>不是即时的</strong>。它们以延迟的异步方式执行。因此，即使拉里执行了<code>#StoreStore</code>，我们也无法对他所有以前的存储何时最终在中央存储库中可见做出任何假设。</p><p>同样，这听起来似乎是一个薄弱的保证，但再次足以防止谢盖尔看到拉里发布的任何过时数据。回到上面的相同示例，拉里只需要将一些数据发布到共享内存，发出<code>#StoreStore</code>屏障，然后将共享标志设置为true：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value = x;                         <span class="comment">// Publish some data</span></span><br><span class="line">STORESTORE_FENCE();</span><br><span class="line">IsPublished = <span class="number">1</span>;                   <span class="comment">// Set shared flag to indicate availability of data</span></span><br></pre></td></tr></table></figure><p>再次，我们指望<code>IsPublished</code>自己从拉里的工作副本泄漏到谢尔盖的。一旦谢尔盖检测到，他就能确信自己会看到的正确<code>Value</code>值。有趣的是，要使这种模式起作用，<code>Value</code>甚至不需要是原子类型。它也可能是一个包含许多元素的巨大结构。</p><h3 id="LoadStore"><a href="#LoadStore" class="headerlink" title="#LoadStore"></a>#LoadStore</h3><p><img src="/images/get-back-to-later.png" alt="img"></p><p>与<code>#LoadLoad</code>和不同<code>#StoreStore</code>，<code>#LoadStore</code>在源代码控制操作方面没有巧妙的隐喻。理解<code>#LoadStore</code>屏障的最好方法很简单，就是在指令重新排序方面。</p><p>想象一下，拉里有一系列要遵循的指示。有些指令使他将自己的私人工作副本中的数据加载到寄存器中，有些指令使他将寄存器中的数据存储回了工作副本中。拉里可以处理指令，但只能在特定情况下使用。每当遇到加载时，他都会提前看看即将出现的任何存储。如果存储与当前加载完全无关，则允许他跳过，先进行存储，然后再返回以完成加载。在这种情况下，仍然遵循内存排序的基本规则（从不修改单线程程序的行为）。</p><p>在实际的CPU上，如果在加载时出现缓存未命中，然后在存储中命中缓存，则某些处理器可能会发生这种指令重新排序。但是就理解比喻而言，此类硬件细节并不重要。我们可以说拉里的工作很无聊，这是他被允许发挥创造力的几次机会之一。他是否选择这样做完全是不可预测的。幸运的是，这是一种相对轻量的重新排序类型；当拉里遇到<code>#LoadStore</code>屏障时，他只是避免围绕该屏障进行这种重新排序。</p><p>以我们的比喻，即使加载与存储之间存在<code>#LoadLoad</code>或<code>#StoreStore</code>屏障，对于拉里执行这种LoadStore重排序也是合法的。但是，在实际的CPU上，充当<code>#LoadStore</code>屏障的指令通常充当其他两种屏障类型中的至少一种。</p><h3 id="StoreLoad"><a href="#StoreLoad" class="headerlink" title="#StoreLoad"></a>#StoreLoad</h3><p>StoreLoad屏障可确保屏障之前执行的所有存储对于其他处理器都是可见的，并且屏障之后执行的所有加载都将收到屏障时可见的最新值。换句话说，它有效地防止了屏障之前所有存储的重新排序，使其免受屏障之后的所有加载的影响，并<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming#sequential-consistency" target="_blank" rel="noopener">遵循顺序一致的</a>多处理器执行这些操作的方式。</p><p><code>#StoreLoad</code>是独特的。这是唯一一种可以防止在 <a href="http://preshing.com/20120515/memory-reordering-caught-in-the-act" target="_blank" rel="noopener">Memory Reordering Caught in the Act</a> 的例子中，出现<code>r1 = r2 = 0</code>结果的内存屏障类型；我在本文前面重复过的示例相同。</p><p>如果您一直在密切关注，您可能会想：<code>#StoreLoad</code>与一个<code>#StoreStore</code>后面跟着一个<code>#LoadLoad</code>有什么区别？毕竟，<code>#StoreStore</code>将更改推送到中央存储库，而<code>#LoadLoad</code>将远程更改拉回。但这两种屏障类型不完备。请记住，推送操作可能会延迟任意数量的指令，并且推送操作可能不会从头部修订版中提取。这暗示了为什么PowerPC的<code>lwsync</code>指令-它充当<code>#LoadLoad</code>，<code>#LoadStore</code>和<code>#StoreStore</code>三个内存障碍，但没有<code>#StoreLoad</code>- 在这个例子中是不足以防止<code>r1 = r2 = 0</code>的。</p><p>从比喻的角度来看，<code>#StoreLoad</code>可以通过将所有本地更改推送到中央后备仓库，等待该操作完成，然后拉动存储库的最新绝对头版修订来实现障碍。在大多数处理器上，充当<code>#StoreLoad</code>屏障的指令往往比充当其他屏障类型的指令更昂贵。</p><p><img src="/images/storeload.png" alt="img"></p><p>如果我们在该操作中设置<code>#LoadStore</code>屏碍，这没什么大不了的，那么我们得到的是完整的内存屏障 - 一次充当所有四种屏障类型。<a href="http://g.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">正如Doug Lea所指出的</a>那样，在所有当前处理器上，每条充当<code>#StoreLoad</code>屏障的指令也充当了完整的内存屏障。</p><h2 id="这个比喻能带您到多远？"><a href="#这个比喻能带您到多远？" class="headerlink" title="这个比喻能带您到多远？"></a>这个比喻能带您到多远？</h2><p>如前所述，每个处理器在内存排序方面都有不同的习惯。尤其是x86/64系列，具有强内存模型。已知将内存重新排序保持在最低限度。PowerPC和ARM的内存模型较弱，而Alpha则以其独树一帜而闻名。幸运的是，本文中提出的类比喻对应于一个<a href="http://preshing.com/20120930/weak-vs-strong-memory-models" target="_blank" rel="noopener">弱内存模型</a>。如果您蒙起头来，并按照此处给出的屏障指令执行正确的内存排序，则您应该能够处理大多数CPU。</p><p>该比喻还非常符合C ++ 11（以前称为C ++ 0x）和C11所针对的抽象机。因此，如果您使用这些语言的标准库编写无锁代码，同时牢记上述类比，则它更有可能在任何平台上正常运行。</p><p>以此比喻，我说过每个程序员代表一个运行在单独内核上的执行线程。在实际的操作系统上，线程倾向于在其整个生命周期中在不同的内核之间移动，但是比喻仍然有效。我还在机器语言的示例和用C/C ++编写的示例之间进行了交替。显然，我们更喜欢使用C/C ++或另一种高级语言。这是可能的，因为任何充当内存屏障的操作都将阻止<a href="http://preshing.com/20120625/memory-ordering-at-compile-time" target="_blank" rel="noopener">编译器重新排序</a>。</p><p>我还没有写关于每种类型的内存屏障的文章。例如，也存在<a href="http://www.mjmwired.net/kernel/Documentation/memory-barriers.txt#305" target="_blank" rel="noopener">数据依赖障碍</a>。我将在以后的文章中进一步描述。</p><p>如果你有兴趣CPU在引擎盖下是如何工作 - 比如存储的缓冲区，高速缓存一致性协议和其他硬件实现细节-为什么他们首先执行内存重新排序，我推荐Paul McKenney &amp; David Howells的<a href="http://www.kernel.org/doc/Documentation/memory-barriers.txt" target="_blank" rel="noopener">优秀成果</a>。的确，我怀疑大多数成功编写了无锁代码的程序员都至少对这种硬件细节有一定的了解。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之内存屏障</title>
      <link href="/cpu_parallel/memory_barrier.html"/>
      <url>/cpu_parallel/memory_barrier.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是内存屏障（Memory-Barrier）"><a href="#什么是内存屏障（Memory-Barrier）" class="headerlink" title="什么是内存屏障（Memory Barrier）"></a>什么是内存屏障（Memory Barrier）</h2><p>内存屏障是一个CPU指令。它是这样一条指令： </p><ol><li>确保一些特定操作执行的顺序；</li><li>影响一些数据的可见性(可能是某些指令执行后的结果)。</li></ol><p>CPU核内部包含了多个执行单元。例如，现代Intel CPU包含了6个执行单元，可以组合进行算术运算，逻辑条件判断及内存操作。每个执行单元可以执行上述任务的某种组合。这些执行单元是并行执行的，这样指令也就是在并行执行。但如果站在另一个CPU角度看，这也就产生了程序顺序的另一种不确定性。即使在单线程环境下，代码执行顺序也不一定是编码时顺序，因为编译器和CPU可以在保证输出结果一样(在自己的线程中)的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。</p><p>内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p><p>当一个程序执行时，只要最终的结果是一样的，指令是否被重排并不重要。例如，在一个循环里，如果循环体内没用到这个计数器，循环的计数器什么时候更新（在循环开始，中间还是最后）并不重要。编译器和CPU可以自由的重排指令以最佳的利用CPU，只要下一次循环前更新该计数器即可。并且在循环执行中，这个变量可能一直存在寄存器上，并没有被推到缓存或主存，这样这个变量对其他CPU来说一直都是不可见的。</p><p>如果一个变量由volatile修饰，Java内存模型将在对这个变量的写操作后插入一个写屏障指令（同步到共享内存），在读操作前插入一个读屏障指令。这意味着如果你对一个volatile变量进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>可见性的定义常见于各种并发场景中，以多线程为例：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。</p><p>从性能角度考虑，没有必要在修改后就立即同步修改的值——如果多次修改后才使用，那么只需要最后一次同步即可，在这之前的同步都是性能浪费。因此，实际的可见性定义要弱一些，只需要保证：<strong>当一个线程修改了线程共享变量的值，其它线程在使用前，能够得到最新的修改值</strong>。</p><blockquote><p>可见性可以认为是最弱的“<code>一致性</code>”（<code>弱一致</code>），只保证用户见到的数据是一致的，但不保证任意时刻，存储的数据都是一致的（<code>强一致</code>）。下文会讨论“缓存可见性”问题，部分文章也会称为“缓存一致性”问题。</p></blockquote><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>一个最简单的可见性问题来自计算机内部的缓存架构：</p><p><img src="/images/160d37bf156d8c0e" alt="image.png"></p><p>缓存大大缩小了高速CPU与低速内存之间的差距。以三层缓存架构为例：</p><ul><li>L1 Cache最接近CPU, 容量最小（如32K、64K等）、速度最高，每个核上都有一个L1 Cache。</li><li>L2 Cache容量更大（如256K）、速度更低, 一般情况下，每个核上都有一个独立的L2 Cache。</li><li>L3 Cache最接近内存，容量最大（如12MB），速度最低，在同一个CPU插槽之间的核共享一个L3 Cache。</li></ul><blockquote><p>准确地说，每个核上有两个L1 Cache, 一个存数据 L1d Cache, 一个存指令 L1i Cache。</p></blockquote><p>单核时代的一切都是那么完美。然而，多核时代出现了可见性问题。一个badcase如下：</p><ol><li>Core0与Core1命中了内存中的同一个地址，那么各自的L1 Cache会缓存同一份数据的副本。</li><li>最开始，Core0与Core1都在友善的读取这份数据。</li><li>突然，Core0要使坏了，它修改了这份数据，使得两份缓存中的数据不同了，更确切的说，Core1 L1 Cache中的数据<code>失效</code>了。</li></ol><p>单核时代只有Core0，Core0修改Core0读，没什么问题；但是，现在_Core0修改后，Core1并不知道数据已经失效，继续傻傻的使用_，轻则数据计算错误，重则导致死循环、程序崩溃等。</p><p>实际的可见性问题还要扩展到两个方向：</p><ul><li>除三级缓存外，<em>各厂商实现的硬件架构中还存在多种多样的缓存，都存在类似的可见性问题</em>。例如，寄存器就相当于CPU与L1 Cache之间的缓存。</li><li>各种高级语言（包括Java）的多线程内存模型中，<em>在线程栈内自己维护一份缓存是常见的优化措施，但显然在CPU级别的缓存可见性问题面前，一切都失效了</em>。</li></ul><blockquote><p>以上只是最简单的可见性问题，不涉及重排序等。</p><p>重排序也会导致可见性问题；同时，缓存上的可见性也会引起一些看似重排序导致的问题。</p></blockquote><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>重排序并没有严格的定义。整体上可以分为两种：</p><ul><li>真·重排序：<strong>编译器、底层硬件（CPU等）出于“优化”的目的</strong>，按照某种规则将指令重新排序（尽管有时候看起来像乱序）。</li><li>伪·重排序：由于<strong>缓存同步顺序</strong>等问题，看起来指令被重排序了。</li></ul><p>重排序也是单核时代非常优秀的优化手段，有足够多的措施保证其在单核下的正确性。在多核时代，如果工作线程之间不共享数据或仅共享不可变数据，重排序也是性能优化的利器。然而，如果工作线程之间共享了可变数据，由于两种重排序的结果都不是固定的，会导致工作线程似乎表现出了随机行为。</p><h3 id="问题来源-1"><a href="#问题来源-1" class="headerlink" title="问题来源"></a>问题来源</h3><p>重排序问题无时无刻不在发生，源自三种场景：</p><ol><li>编译器编译时的优化</li><li>处理器执行时的乱序优化</li><li>缓存同步顺序（导致可见性问题）</li></ol><p>场景1、2属于真·重排序；场景3属于伪·重排序。场景3也属于可见性问题，为保持连贯性，我们先讨论场景3。</p><h4 id="可见性导致的伪·重排序"><a href="#可见性导致的伪·重排序" class="headerlink" title="可见性导致的伪·重排序"></a>可见性导致的伪·重排序</h4><p>缓存同步顺序本质上是可见性问题。</p><p>假设<code>程序顺序</code>（program order）中先更新变量v1、再更新变量v2，不考虑真·重排序：</p><ol><li>Core0先更新缓存中的v1，再更新缓存中的v2（位于两个缓存行，这样淘汰缓存行时不会一起写回内存）。</li><li>Core0读取v1（假设使用LRU协议淘汰缓存）。</li><li>Core0的缓存满，将最远使用的v2写回内存。</li><li>Core1的缓存中本来存有v1，现在将v2加载入缓存。</li></ol><blockquote><p>重排序是针对程序顺序而言的，如果指令执行顺序与程序顺序不同，就说明这段指令被重排序了。</p></blockquote><p>此时，<em>尽管“更新v1”的事件早于“更新v2”发生，但Core1只看到了v2的最新值，却看不到v1的最新值</em>。这属于可见性导致的<strong>伪·重排序：虽然没有实际上没有重排序，但看起来发生了重排序</strong>。</p><p>可以看到，缓存可见性不仅仅导致可见性问题，还会导致伪·重排序。因此，<em>只要解决了缓存上的可见性问题，也就解决了伪·重排序</em>。</p><h2 id="内存屏障指令"><a href="#内存屏障指令" class="headerlink" title="内存屏障指令"></a>内存屏障指令</h2><p>同步的目的是保证不同执行流对共享数据并发操作的一致性。在单核时代，使用原子变量就很容易达成这一目的。甚至因为CPU的一些访存特性，对某些内存对齐数据的读或写也具有原子的特性。但在多核架构下即使操作是原子的，仍然会因为其他原因导致同步失效。</p><p>解决种种重排列和不可见问题的靠近硬件的解决方法是内存屏障，无论是Acquire/Release语义还是原子操作，亦或者是互斥锁，在底层实现均依赖于内存屏障指令。</p><h3 id="LoadLoad"><a href="#LoadLoad" class="headerlink" title="#LoadLoad"></a>#LoadLoad</h3><p>该屏障之前的读不会乱序到该屏障之后，用版本管理系统类比的话相当于<code>git pull</code>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load1<span class="comment">; </span></span><br><span class="line">LoadLoad<span class="comment">; </span></span><br><span class="line">Load2<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>Load1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。Load1读取到的值有可能不是最新的，这取决于其它线程的读写情况。但至少不会出现下面的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsPublished)                   <span class="comment">// Load and check shared flag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LOADLOAD_FENCE();              // Prevent reordering of loads</span></span><br><span class="line">    <span class="keyword">return</span> Value;                  <span class="comment">// Load published value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能IsPublished还不为<code>true</code>(意味着其它线程对<code>Value</code>还没写好)，就先读了旧的Value，如果没有LoadLOad屏障的话。</p><h3 id="StoreStore"><a href="#StoreStore" class="headerlink" title="#StoreStore"></a>#StoreStore</h3><p>该屏障之前的写不会乱序到该屏障之后，用版本管理系统类比的话相当于<code>git push</code>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Store1<span class="comment">; </span></span><br><span class="line">StoreStore<span class="comment">; </span></span><br><span class="line">Store2<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>Store1 和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见，即强制更新一次不同CPU的缓存。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value = x;                         <span class="comment">// Publish some data</span></span><br><span class="line">STORESTORE_FENCE();</span><br><span class="line">IsPublished = <span class="number">1</span>;                   <span class="comment">// Set shared flag to indicate availability of data</span></span><br></pre></td></tr></table></figure><p>如果其它线程看到<code>IsPublished</code>的值为1，那么数据一定已经写到共享内存中。</p><h3 id="LoadStore"><a href="#LoadStore" class="headerlink" title="#LoadStore"></a>#LoadStore</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Load1; </span><br><span class="line">LoadStore; </span><br><span class="line">Store2;</span><br></pre></td></tr></table></figure><p>在Store2被写入前，保证Load1要读取的数据被读取完毕。</p><h3 id="StoreLoad"><a href="#StoreLoad" class="headerlink" title="#StoreLoad"></a>#StoreLoad</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Store1; </span><br><span class="line">StoreLoad;</span><br><span class="line">Load2;</span><br></pre></td></tr></table></figure><p>在Load2读取操作执行前，保证Store1的写入对所有处理器可见。StoreLoad屏障的开销是四种屏障中最大的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5a52cfdc518825733b0eb69a#heading-15" target="_blank" rel="noopener">https://juejin.im/post/5a52cfdc518825733b0eb69a#heading-15</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11线程库使用</title>
      <link href="/C++/cpp11_thread.html"/>
      <url>/C++/cpp11_thread.html</url>
      
        <content type="html"><![CDATA[<p>从C++11开始，在STL中提供了<code>thread</code>模块对操作系统的C线程库进行了封装，避免了跨平台问题。但是，很多人觉得这个库封装的不够好。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>C++11中提供了如下4种语义的互斥量(mutex):</p><ul><li>std::mutex：独占的互斥量，不能递归使用。</li><li>std::timed_mutex：带超时的独占互斥量，不能递归使用。</li><li>std::recursive_mutex：递归互斥量，不带超时功能。</li><li>std::recursive_timed_mutex：带超时的递归互斥量。</li></ul><p>这些互斥量的基本接口很相似，一般用法是通过lock()方法来阻塞线程，直到获得互斥量的所有权为止。在线程获得互斥量并完成任务之后，就必须使用unlock()来解除对互斥量的占用，lock()和unlock()必须成对出现。try_lock()尝试锁定互斥量，如果成功则返回true，如果失败则返回false，它是非阻塞的。</p><h4 id="独占互斥量std-mutex"><a href="#独占互斥量std-mutex" class="headerlink" title="独占互斥量std::mutex"></a>独占互斥量std::mutex</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line">mutex m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1_func</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.lock();</span><br><span class="line">    <span class="comment">// 在这里写上你需要的代码</span></span><br><span class="line">    m.unlock();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(thread_func, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(thread_func, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用lock_guard可以简化lock/unlock的写法，同时也更安全，因为lock_guard在构造时会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记unlock操作，因此，应尽量用lokc_guard。lock_guard用到了RAII技术，这种技术在类的构造函数中分配资源，在析构函数中释放资源，保证资源在出了作用域之后就释放。上面的例子使用lock_guard后会更简洁，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock_guard&lt;<span class="built_in">std</span>::mutex&gt; locker(m);   <span class="comment">// 出作用域之后自动解锁</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"entered thread "</span> &lt;&lt;this_thread::get_id() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"leaving thread "</span> &lt;&lt;<span class="built_in">std</span>::this_thread::get_id() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归的独占互斥量std-recursive-mutex"><a href="#递归的独占互斥量std-recursive-mutex" class="headerlink" title="递归的独占互斥量std::recursive_mutex"></a>递归的独占互斥量std::recursive_mutex</h4><p>递归锁允许同一线程多次获得该互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题。一个线程多次获取同一个互斥量时会发生死锁。要解决这个死锁的问题，一个简单的办法就是用递归锁：std::recursive_mutex，它允许同一线程多次获得互斥量。</p><p>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::recursive_mutex mutex;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    Complex():i(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lock(mutex);</span><br><span class="line">        i*=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lock(mutex);</span><br><span class="line">        i/=x;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">both</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::recursive_mutex&gt; lock(mutex);</span><br><span class="line">        mul(x);</span><br><span class="line">        div(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Complex <span class="keyword">complex</span>;</span><br><span class="line">    <span class="keyword">complex</span>.both(<span class="number">32</span>, <span class="number">23</span>);  <span class="comment">// 因为同一线程可以多次获取同一互斥量，不会发生死锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是尽量不要使用递归锁好，主要原因如下：</p><ol><li>需要用到递归锁定的多线程互斥处理往往本身就是可以简化的，允许递归互斥很容易放纵复杂逻辑产生，从而导致一些多线程同步引起的晦涩问题。</li><li>递归锁比起非递归锁，效率会低一些。</li><li>递归锁虽然允许同一个线程多次获得同一互斥量，可重复获得的最大次数并未具体说明，一旦超过一定次数，再对lock进行调用就会抛出std::system错误。</li></ol><h4 id="带超时的互斥量"><a href="#带超时的互斥量" class="headerlink" title="带超时的互斥量"></a>带超时的互斥量</h4><p>std::timed_mutex是超时的独占锁，std::recursive_timed_mutex是超时的递归锁，主要用在获取锁时超时等待功能，因为有时不知道获取锁需要多久，为了不至于一直在等待获取互斥量，就设置一个等待超时时间，在超时后还可以做其他事情。std::timed_mutex比std::mutex多了两个超时获取锁的接口：try_lock_for和try_lock_until，这两个接口是用来设置获取互斥量的超时时间。</p><p>std::timed_mutex的基本用法如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::timed_mutex mutex1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    chrono::<span class="function">milliseconds <span class="title">timeout</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mutex1.try_lock_for(timeout)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;this_thread::get_id() &lt;&lt;<span class="string">":do work with the mutex"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            chrono::<span class="function">milliseconds <span class="title">sleepDuration</span><span class="params">(<span class="number">250</span>)</span></span>;</span><br><span class="line">            this_thread::sleep_for(sleepDuration);</span><br><span class="line">    </span><br><span class="line">            mutex1.unlock();</span><br><span class="line">            this_thread::sleep_for(sleepDuration);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;this_thread::get_id() &lt;&lt;<span class="string">": do work without mutex"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            chrono::<span class="function">milliseconds <span class="title">sleepDuration</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">            this_thread::sleep_for(sleepDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(work)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(work)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，通过一个while循环不断地去获取超时锁，如果超时还没有获取到锁时就休眠100毫秒，再继续获取超时锁。相比std::timed_mutex，std::recursive_timed_mutex多了递归锁的功能，允许同一线程多次获得互斥量。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是C++11提供的另外一种用于同步线程的机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时，才会唤醒当前阻塞的线程。条件变量需要和互斥量配合起来用。C++11提供了两种条件变量：</p><ul><li>condition_variable，配合<code>std::unique_lock&lt;std::mutex&gt;</code>进行wait操作。</li><li>condition_variable_any，和任意带有lock、unlock语义的mutex搭配使用，比较灵活，但效率比condition_variable差一些。</li></ul><p>可以看到condition_variable_any比condition_variable更灵活，因为它更通用，对所有的锁都适用，而condition_variable性能更好。</p><p>条件变量的使用过程如下：</p><ol><li>拥有条件变量的线程获取互斥量。</li><li>循环检查某个条件，如果条件不满足，则阻塞直到条件满足；如果条件满足，则向下执行。</li><li>某个线程满足条件执行完之后调用notify_one或notify_all唤醒一个或者所有的等待线程。</li></ol><p>我们可以看一个经典的生产者-消费者的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mutex m_mutex;   <span class="comment">// 互斥量</span></span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;         <span class="comment">// 共享资源</span></span><br><span class="line">condition_variable m_notempty;   <span class="comment">// 条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        m_mutex.lock();  <span class="comment">// 上锁</span></span><br><span class="line">        s++;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"increase one ,s="</span> &lt;&lt;s &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        m_mutex.unlock();</span><br><span class="line">        </span><br><span class="line">        m_notempty.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;    <span class="comment">// 消费者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123; </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        unique_lock&lt;mutex&gt; locker(m_mutex);  </span><br><span class="line">        <span class="keyword">while</span>(s==<span class="number">0</span>)  m_notempty.wait(locker);      <span class="comment">// 使用条件变量</span></span><br><span class="line">        <span class="comment">// 或</span></span><br><span class="line">        <span class="comment">// m_notempty.wait(locker, []&#123; return s &gt; 0; &#125;); </span></span><br><span class="line">        s--;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"decrease one,s="</span> &lt;&lt;s &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">thread <span class="title">thread1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thread2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中<code>while(s==0) m_notempty.wait(locker);</code> ，这句代码的意思的是当s等于0的时候，阻塞直到条件满足时被唤醒。我们也可以这么用， <code>m_notempty.wait(locker, []{ return s &gt; 0; });</code>，将判断条件放到函数里面，意思是wait将一直阻塞，知道判断条件满足时，被唤醒。</p><h3 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h3><p>C++11提供了一个原子类型<code>std::atomic&lt;T&gt;</code>，可以使用任意类型作为模板参数，C++11内置了整型的原子变量，可以更方便地使用原子变量，使用原子变量就不需要使用互斥量来保护该变量了，因为对该变量的操作保证其是原子的，是不可中断的。用起来更简洁。</p><p>要做一个计时器，使用mutex时，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">std</span>::mutex m_mutex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line">        ++value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line">        --value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果使用原子变量，就不需要再定义互斥量了，使用更简便。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="call-one-once-flag的使用"><a href="#call-one-once-flag的使用" class="headerlink" title="call_one/once_flag的使用"></a>call_one/once_flag的使用</h4><p>为了保证在多线程环境中某个函数仅被调用一次，比如，需要初始化某个对象，而这个对象只能初始化一次时，就可以用std::call_once来保证函数在多线程环境中只被调用一次。使用std::call_once时，需要一个once_flag作为call_one的入参，它的用法比较简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_once</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag, []&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"Called once"</span> &lt;&lt;<span class="built_in">endl</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(do_once)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(do_once)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(do_once)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>Called once</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/fengxinlinux/article/details/76686829" target="_blank" rel="noopener">https://blog.csdn.net/fengxinlinux/article/details/76686829</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】成员函数的重载、覆盖与隐藏</title>
      <link href="/C++/overload_override_and_hide.html"/>
      <url>/C++/overload_override_and_hide.html</url>
      
        <content type="html"><![CDATA[<p>成员函数的重载（overload）、覆盖（override）与隐藏很容易混淆，梳理如下：</p><h2 id="一、重载"><a href="#一、重载" class="headerlink" title="一、重载"></a>一、重载</h2><p>《高质量C++/C编程指南》已经清晰的列出了重载函数的特性：</p><pre><code>（1）相同的范围（在同一个类中）；（2）函数名字相同；（3）参数不同；（4）virtual关键字可有可无。</code></pre><p>因为重载的函数之间参数不同，所以重载的函数们是不同的函数，编译器能够明确的根据不同的参数来调用不同的函数。重载函数与返回值类型无关。</p><h2 id="二、覆盖（重写、多态）"><a href="#二、覆盖（重写、多态）" class="headerlink" title="二、覆盖（重写、多态）"></a>二、覆盖（重写、多态）</h2><p>覆盖，是指 派生类函数覆盖基类函数，特性如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）不同的范围（分别位于派生类与基类）； </span><br><span class="line">（<span class="number">2</span>）函数名字相同；</span><br><span class="line">（<span class="number">3</span>）参数相同；</span><br><span class="line">（<span class="number">4</span>）基类函数必须有virtual关键字。</span><br></pre></td></tr></table></figure><p>这里会用到虚函数，实际上虚函数的作用，就是实现覆盖（多态）。</p><h2 id="三、隐藏"><a href="#三、隐藏" class="headerlink" title="三、隐藏"></a>三、隐藏</h2><p>隐藏，是指派生类函数将基类函数给藏起来了，当然只作用于派生类函数，其特性与覆盖不同。两种情况下属于隐藏：</p><pre><code>（1）如果派生类的函数与基类的函数同名，参数不同，不论有无virtual关键字，基类函数会被隐藏。（2）如果派生类的函数与基类的函数同名，参数相同，基类函数没有virtual关键字。此时，基类的函数被隐藏。</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】临时对象</title>
      <link href="/C++/temporary_object.html"/>
      <url>/C++/temporary_object.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、临时量与临时对象"><a href="#一、临时量与临时对象" class="headerlink" title="一、临时量与临时对象"></a>一、临时量与临时对象</h2><p>临时量：</p><ol><li><p>内置类型生成的临时量是常量（临时量，寄存器带出来）。</p></li><li><p>自定义类型生成的临时量是变量 ，在内存中。</p></li></ol><p>临时对象：</p><p>临时对象是系统临时分配的对象，在没主动声明所需对象而又使用其功能时产生的</p><p>注意: 临时对象的生存周期只在本条语句。</p><h2 id="二、哪些情况产生临时量"><a href="#二、哪些情况产生临时量" class="headerlink" title="二、哪些情况产生临时量"></a>二、哪些情况产生临时量</h2><h3 id="2-1-调用构造函数生成的对象"><a href="#2-1-调用构造函数生成的对象" class="headerlink" title="2.1 调用构造函数生成的对象"></a>2.1 调用构造函数生成的对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> x);</span><br><span class="line"><span class="comment">// explicit A(int x);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(A aObject)</span></span>;</span><br><span class="line">A aObj;  <span class="comment">// 显示对象</span></span><br><span class="line">doSomething(aObj);  </span><br><span class="line">doSomething(<span class="number">28</span>);  <span class="comment">// 产生了隐式临时对象，编译器调用A(28)将28隐式构造成A类对象</span></span><br><span class="line">doSomething(A(<span class="number">28</span>));  <span class="comment">// 产生了显示临时对象</span></span><br></pre></td></tr></table></figure><p>如果不想让编译器隐式调用构造函数，只需用explicit修饰只需要传一个参数的构造函数。</p><h2 id="三、临时变量的引用"><a href="#三、临时变量的引用" class="headerlink" title="三、临时变量的引用"></a>三、临时变量的引用</h2><h3 id="3-1-禁止非常量引用"><a href="#3-1-禁止非常量引用" class="headerlink" title="3.1 禁止非常量引用"></a>3.1 禁止非常量引用</h3><p>《Effective C++ 第三版》第二十一条规劝，返回对象时，别妄想返回其引用。根源在于：临时对象的生命周期只在本语句。函数返回时，临时变量会被销毁，将引用一个被销毁的对象，这种行为未定义。</p><p>在VS2013下测试，函数参数为非常量引用指向临时对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(<span class="string">"hello jiang"</span>);  <span class="comment">// 错误，"hello jiang"被转成string临时对象，无法非常量引用临时对象</span></span><br></pre></td></tr></table></figure><p>上面代码无法编译通过，说明编译器明确指出了这种写法是错误的。错误前置出现在编译期间，较好防范。</p><p>在VS2013下测试，函数返回值为非常量引用指向临时对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">f2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;a = f2();  <span class="comment">// 编译通过</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面代码编译通过了，但是存在潜在风险，程序行为未定义。这种情况尤为注意，因为错误将在运行期出现。其实我好奇的是C++标准为什么不延长这种情况下，临时变量的生命周期。</p><h3 id="3-2-常量引用"><a href="#3-2-常量引用" class="headerlink" title="3.2 常量引用"></a>3.2 常量引用</h3><p>临时变量是由编译器生成的，C++语言规范没规定编译器生成临时变量的规则，程序员无法得知由编译器生成的临时变量的名字，程序员无法访问那个临时变量。这意味着，以引用的方式传递一个临时变量做为函数参数，如果函数内部对此临时变量做了修改，那么函数返回后，程序员无法获得函数对临时变量的修改。函数对临时变量所做出的所有更改，都将丢失。C++标准为防止给常量或临时变量（只有瞬间的生命周期）赋值(易产生bug)，只许使用const引用之。</p><p>在VS2013下测试，函数参数为常量引用指向临时对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f3(<span class="string">"hello jiang"</span>);  <span class="comment">// 允许，"hello jiang"被隐式转成string临时对象，使用常量引用之。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在VS2013下测试，函数返回值为常量引用指向临时对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> &amp; <span class="title">f4</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;a = f4();  <span class="comment">// 允许</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、优化包含临时对象的程序"><a href="#四、优化包含临时对象的程序" class="headerlink" title="四、优化包含临时对象的程序"></a>四、优化包含临时对象的程序</h2><ul><li>函数调用传对象时，如果可以，尽量按对象引用来传递，避免构造临时对象</li><li>函数调用时，按对象引用来传递，如果不需要修改对象，使用const引用，以避免无意修改对象。</li><li>返回对象时，别妄想返回其引用</li><li>调用返回对象的函数时，应该以初始化的方式调用，不要以赋值的方式调用，否则会多调用一次构造函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】215 数组中的第K个最大元素</title>
      <link href="/leetcode/leetcode_215.html"/>
      <url>/leetcode/leetcode_215.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] 和 k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">        sort(nums, l, j<span class="number">-1</span>);</span><br><span class="line">        sort(nums, j+<span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = nums[l];</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">int</span> j = h + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[++i] &gt; v) <span class="keyword">if</span> (i &gt;= h) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[--j] &lt; v) <span class="keyword">if</span> (j &lt;= l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            exch(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(nums, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        random_shuffle(nums.begin(), nums.end());  <span class="comment">// 打乱顺序</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>排序</strong> ：时间复杂度 O(nlogn)，空间复杂度 O(1) </p><h2 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h2><p>创建一个小顶堆，将所有数组中的元素加入堆中，并保持堆的大小小于等于 <code>k</code>。这样堆中就保留了前 <code>k</code> 个最大的元素。堆顶的元素就是第k大元素。 </p><p>下面使用堆的写法，修改了输入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        make_heap(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">while</span>(--k &gt; <span class="number">0</span>) &#123;  <span class="comment">// // k</span></span><br><span class="line">            pop_heap(nums.begin(), nums.end());  <span class="comment">// logn</span></span><br><span class="line">            nums.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; nums.size(); ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     printf("nums[%d]=%d\n", i, nums[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>O(klogn) 时间， O(n) 空间</p><p>使用优先队列写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; min_heap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;  <span class="comment">// n</span></span><br><span class="line">            min_heap.push(nums[i]);  <span class="comment">// logk</span></span><br><span class="line">            <span class="keyword">if</span> (min_heap.size() &gt; k) min_heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_heap.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>O(nlogk) 时间， O(k) 空间</p><p>虽然理论上当k&lt;n时，最小堆比使用快排快，但在LeetCode上测试多次均是快排快。优先队列是对堆的包装，某些场合下比堆好用。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】 241. 为运算表达式设计优先级</title>
      <link href="/leetcode/leetcode_241.html"/>
      <url>/leetcode/leetcode_241.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"2-1-1"</span></span><br><span class="line">输出: [<span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">解释: </span><br><span class="line">((<span class="number">2</span><span class="number">-1</span>)<span class="number">-1</span>) = <span class="number">0</span> </span><br><span class="line">(<span class="number">2</span>-(<span class="number">1</span><span class="number">-1</span>)) = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"2*3-4*5"</span></span><br><span class="line">输出: [<span class="number">-34</span>, <span class="number">-14</span>, <span class="number">-10</span>, <span class="number">-10</span>, <span class="number">10</span>]</span><br><span class="line">解释: </span><br><span class="line">(<span class="number">2</span>*(<span class="number">3</span>-(<span class="number">4</span>*<span class="number">5</span>))) = <span class="number">-34</span> </span><br><span class="line">((<span class="number">2</span>*<span class="number">3</span>)-(<span class="number">4</span>*<span class="number">5</span>)) = <span class="number">-14</span> </span><br><span class="line">((<span class="number">2</span>*(<span class="number">3</span><span class="number">-4</span>))*<span class="number">5</span>) = <span class="number">-10</span> </span><br><span class="line">(<span class="number">2</span>*((<span class="number">3</span><span class="number">-4</span>)*<span class="number">5</span>)) = <span class="number">-10</span> </span><br><span class="line">(((<span class="number">2</span>*<span class="number">3</span>)<span class="number">-4</span>)*<span class="number">5</span>) = <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>分治法的设计思想是，将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。 首先按操作符循环，即确定分治的出发点。然后分别计算操作符左边结果和操作符右边结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfs(<span class="keyword">const</span> <span class="built_in">string</span>&amp; input, <span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s+<span class="number">1</span>; i &lt; e; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] == <span class="string">'+'</span> || input[i] == <span class="string">'-'</span> || input[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = dfs(input, s, i);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = dfs(input, i+<span class="number">1</span>, e);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> l : left) <span class="keyword">for</span> (<span class="keyword">auto</span> r : right) ans.push_back(ops(l, input[i], r));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全是数字</span></span><br><span class="line">        <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) ans.push_back(stoi(input.substr(s, e-s)));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ops</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">char</span> op, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">return</span> l+r;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> l-r;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">return</span> l*r;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;  <span class="comment">// error!</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diffWaysToCompute(<span class="built_in">string</span> input) &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(input, <span class="number">0</span>, input.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节</strong> </p><p>如果在使用分治思想递归过程觉得大问题和子问题函数的返回值不同，说明这个问题分解没想清楚，否则必然是相同的问题，相同的返回值类型。</p><h2 id="带备忘录的分治"><a href="#带备忘录的分治" class="headerlink" title="带备忘录的分治"></a>带备忘录的分治</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 不能使用unordered_map, 因为pair没有hash函数</span></span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res_map;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfs(<span class="keyword">const</span> <span class="built_in">string</span>&amp; input, <span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res_map.find(make_pair(s, e)) != res_map.end()) <span class="keyword">return</span> res_map[make_pair(s, e)];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s+<span class="number">1</span>; i &lt; e; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] == <span class="string">'+'</span> || input[i] == <span class="string">'-'</span> || input[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = dfs(input, s, i);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = dfs(input, i+<span class="number">1</span>, e);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> l : left) <span class="keyword">for</span> (<span class="keyword">auto</span> r : right) ans.push_back(ops(l, input[i], r));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全是数字</span></span><br><span class="line">        <span class="keyword">if</span> (ans.size() == <span class="number">0</span>) ans.push_back(stoi(input.substr(s, e-s)));</span><br><span class="line">        <span class="comment">// res_map.insert(make_pair(make_pair(s, e), ans));</span></span><br><span class="line">        res_map[make_pair(s, e)] = ans;  <span class="comment">// 高效一些</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ops</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">char</span> op, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">return</span> l+r;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> l-r;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">return</span> l*r;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;  <span class="comment">// error!</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diffWaysToCompute(<span class="built_in">string</span> input) &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(input, <span class="number">0</span>, input.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode之75. 颜色分类</title>
      <link href="/leetcode/leetcode_75_sort-colors.html"/>
      <url>/leetcode/leetcode_75_sort-colors.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意: 不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>进阶：</p><ul><li>一直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul><h2 id="三向切分"><a href="#三向切分" class="headerlink" title="三向切分"></a>三向切分</h2><p>这道题在边界条件上花费了很多时间。这个算法太容易写错了。注意与《算法》第四版189页代码的不同，书上v选取了第一个元素，所以，curr初始值为lt+1，任何时刻nums[lt]都为v，因此与nums[lt]交换后curr可向前移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = <span class="number">0</span>;  <span class="comment">// nums[0..lt-1] &lt; 1, nums[lt] &lt;= 1, 因此与nums[lt]交换后curr可向前移动</span></span><br><span class="line">        <span class="keyword">int</span> gt = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = lt;<span class="comment">// 开始与lt必须指向相同位置，保证不漏排任何一个元素</span></span><br><span class="line">        <span class="keyword">while</span> (curr &lt;= gt) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = nums[curr] - v;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) exch(nums, curr, gt--);  <span class="comment">// 这里curr不能加加，否则就漏排与curr交换了的nums[gt]</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; <span class="number">0</span>) exch(nums, curr++, lt++);  <span class="comment">// 这里curr一定要加加，否则循环可能前进不动</span></span><br><span class="line">            <span class="keyword">else</span> curr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之背包模型</title>
      <link href="/algorithm/dp_bag_model.html"/>
      <url>/algorithm/dp_bag_model.html</url>
      
        <content type="html"><![CDATA[<p>背包模型从形式上看属于二维DP。</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p><strong>问题描述</strong>： 有 N 个物品和一个容量为 V 的背包， 放入第 i 个物品耗费的空间是Ci，得到的价值是Wi。求解价值总和最大值？（或求解将哪些物品装入背包可使价值总和最大 ）</p><p><strong>状态定义</strong>：<br> <code>f[i][v]</code>表示 i 个物品恰好放入一个容量为 v 的背包可以获得的最大价值。注意这个状态定义不是问题的状态，是个一般性的状态表示，代入N、V才是问题的状态。小v可以是任意一个可能的容量。</p><p><strong>决策</strong>：<br>假设前一阶段的状态是最优状态（最优子结构），考虑第i个物品放还是不放。</p><p><strong>状态转移</strong>：</p><p>物体从少到多、包容量从小到大转移状态。放的话，意味着前一个状态背包容量最大为v-Ci，即状态为<code>f[i-1][v-Ci]+Wi</code>，这是一个子问题。不放，意味着放不下，否则定能使价值提高，状态为<code>f[i-1][v]</code>。因此得到，</p><p> <code>f[i][v] = max(f[i-1][v-Ci]+Wi, f[i-1][v])</code></p><p>假设前一阶段的状态是最优状态成立的条件是，可以得到类似上面的状态转移方程。</p><p>最后就是从已知的初始状态转移到问题状态。</p><p> <strong>时间复杂度</strong>：<code>O(V*N)</code></p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><strong>问题描述</strong>：有N种物品（每种物品无限件）和一个容量为V的背包。放入一个第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解价值总和最大值？（或求解将哪些物品装入背包可使价值总和最大 ）</p><p><strong>状态定义</strong>：<code>f[i][v]</code>表示 i 种物品放入背包容量为v可以获得的最大价值。</p><p><strong>决策</strong>：<br>在前一个阶段的状态基础上，考虑放第 i 种物品。</p><p><strong>状态转移</strong>：<br>放的话，假设第 i 种放 k 个，此时前一个阶段状态为 <code>f[i-1][v-k*Ci]</code>；不放的话相当于k=0，k的范围是[0, v/Ci]，因此得到：<br><code>f[i][v] = max{ f[i-1][v-kCi] + kWi | 0 &lt;= k &lt;= v/Ci}</code><br> 当k的取值为0,1时，这就是0-1背包的状态转移方程 </p><p> <strong>时间复杂度</strong>：<code>O(V*N*sum{V/Ci})</code></p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p><strong>问题描述</strong>：有N种物品（每种物品Mi件）和一个容量为V的背包。放入第i种物品耗费的空间是Ci，得到的价值是Wi。求解价值总和最大值？（或求解将哪些物品装入背包可使价值总和最大 ）</p><p><strong>状态定义</strong>： <code>f[i][v]</code>表示 i 种物品放入一个容量为v的背包可以获得的最大价值。 </p><p><strong>决策</strong>：<br>在前一个阶段的状态基础上，考虑放第 i 种物品。</p><p><strong>状态转移</strong>：</p><p>放的话，假设第 i 种放 k 个，此时前一个阶段状态为 <code>f[i-1][v-k*Ci]</code>，不放的话相当于k=0，k的范围是<code>[0, min(Mi, v/Ci)]</code>，因此得到，</p><p><code>f[i][v] = max{ f[i-1][v - kCi] + kWi | 0 &lt;= k &lt;= min(Mi, v/Ci) }</code></p><p> <strong>时间复杂度</strong>：<code>O(V*N*sum{min(Mi, V/Ci)})</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_70 爬楼梯</title>
      <link href="/leetcode/leetcode_70.html"/>
      <url>/leetcode/leetcode_70.html</url>
      
        <content type="html"><![CDATA[<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span> <span class="number">2</span> 阶</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure><p>典型的解法是动态规划。</p><p>这个问题可以被分解为一些包含最优子结构的子问题，即它的最优解可以从其子问题的最优解来有效地构建，我们可以使用动态规划来解决这一问题。</p><p>第 i 阶可以由以下两种方法得到：</p><ol><li><p>在第 (i-1) 阶后向上爬 1 阶。</p></li><li><p>在第 (i-2) 阶后向上爬 2 阶。</p></li></ol><p>所以到达第 i 阶的方法总数就是到第 (i-1) 阶和第 (i-2) 阶的方法数之和。</p><p>令 dp[i]表示能到达第 i阶的方法总数：dp[i]=dp[i-1]+dp[i-2]</p><p>本文主要为了说明这个公式，为什么到达第 i 阶的方法总数就是到第 (i-1) 阶和第 (i-2) 阶的方法数之和？到达第 (i-1) 阶的方法和达到第 (i-2) 阶的方法里难道没有重复的？</p><p>其实只看到达<code>第 (i-1) 阶的方法</code>和达到<code>第 (i-2) 阶的方法</code>，确实可能有重复的。但是达到<code>第 i 阶的方法</code>中<code>第 (i-1) 阶的方法+1</code> 与 <code>第 (i-2) 阶方法+2</code>，这两者绝无可能重复，且没有遗漏，所以是典型的动态规划问题，大问题可以分解成同样的小问题加以解决。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：O(n)，单循环到 n 。</li><li>空间复杂度：O(n)，dp 数组用了 n 的空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git之常用命令</title>
      <link href="/git/git_command.html"/>
      <url>/git/git_command.html</url>
      
        <content type="html"><![CDATA[<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为xxx的新分支，并切到新分支</span></span><br><span class="line">git checkout -b xxx</span><br><span class="line"><span class="comment"># checkout -b 是复合命令，一个是创建，一个是切换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前所有的分支，结果显示带*号的，而且颜色是绿色的即为我们当前所在的分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地xxx分支</span></span><br><span class="line">git branch -d xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程xxx分支</span></span><br><span class="line">git push origin --delete xxx</span><br></pre></td></tr></table></figure><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并master分支到当前分支</span></span><br><span class="line">git merge master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并xxx分支到master（先切到master分支）</span></span><br><span class="line">git merge xxx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA C编程指南</title>
      <link href="/cuda/cuda_c_programming_guide.html"/>
      <url>/cuda/cuda_c_programming_guide.html</url>
      
        <content type="html"><![CDATA[<h2 id="CUDA程序执行流程"><a href="#CUDA程序执行流程" class="headerlink" title="CUDA程序执行流程"></a>CUDA程序执行流程</h2><p>典型的CUDA程序的执行流程如下：</p><ol><li>分配host内存，并进行数据初始化；</li><li>分配device内存，并从host将数据拷贝到device上；</li><li>调用CUDA的核函数在device上完成指定的运算；</li><li>将device上的运算结果拷贝到host上；</li><li>释放device和host上分配的内存。</li></ol><p>kernel是在device上线程中并行执行的函数，核函数用<code>__global__</code>符号声明，在调用时需要用<code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code>来指定kernel要执行的线程数量，在CUDA中，每一个线程都要执行核函数，并且每个线程会分配一个唯一的线程号thread ID，这个ID值可以通过核函数的内置变量<code>threadIdx</code>来获得。</p><p>CUDA中是通过函数类型限定词开区别host和device上的函数，主要的三个函数类型限定词如下：</p><ul><li><code>__global__</code>：在device上执行，从host中调用（一些特定的GPU也可以从device上调用），返回类型必须是void，不支持可变参数参数，不能成为类成员函数。注意用<code>__global__</code>定义的kernel是异步的，这意味着host不会等待kernel执行完就执行下一步。</li><li><code>__device__</code>：在device上执行，单仅可以从device中调用，不可以和<code>__global__</code>同时用。</li><li><code>__host__</code>：在host上执行，仅可以从host上调用，一般省略不写，不可以和<code>__global__</code>同时用，但可和<code>__device__</code>，此时函数会在device和host都编译。</li></ul><h2 id="CUDA线程"><a href="#CUDA线程" class="headerlink" title="CUDA线程"></a>CUDA线程</h2><h3 id="逻辑层次"><a href="#逻辑层次" class="headerlink" title="逻辑层次"></a>逻辑层次</h3><p>GPU上很多并行化的轻量级线程。kernel在device上执行时实际上是启动很多线程，一个kernel所启动的所有线程称为一个网格（grid），grid是线程结构的第一层次，而网格又可以分为很多线程块（block），一个线程块里面包含很多线程，这是第二个层次。线程两层组织结构如下图所示，这是一个gird和block均为2-dim的线程组织。grid和block都是定义为dim3类型的变量，dim3可以看成是包含三个无符号整数（x，y，z）成员的结构体变量，在定义时，缺省值初始化为1。因此grid和block可以灵活地定义为1-dim，2-dim以及3-dim结构，对于图中结构（主要水平方向为x轴），定义的grid和block如下所示，kernel在调用时也必须通过执行配置&lt;&lt;&lt;grid, block&gt;&gt;&gt;来指定kernel所使用的线程数及结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">kernel_fun&lt;&lt;&lt; grid, block &gt;&gt;&gt;(prams...);</span><br></pre></td></tr></table></figure><p><img src="/images/Kernel%E4%B8%8A%E7%9A%84%E4%B8%A4%E5%B1%82%E7%BA%BF%E7%A8%8B%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%EF%BC%882-dim%EF%BC%89.jpg" alt="Kernel上的两层线程组织结构（2-dim）"></p><p><img src="/images/1093303-20180919123018799-1605248744.png" alt="img"></p><p>所以，一个线程需要两个内置的坐标变量（blockIdx，threadIdx）来唯一标识，它们都是dim3类型变量，其中blockIdx指明线程所在grid中的位置，而threaIdx指明线程所在block中的位置，如图中的Thread (1,1)满足：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadIdx.x = <span class="number">1</span></span><br><span class="line">threadIdx.y = <span class="number">1</span></span><br><span class="line">blockIdx.x = <span class="number">1</span></span><br><span class="line">blockIdx.y = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>一个线程块上的线程是放在同一个流式多处理器（SM)上的，但是单个SM的资源有限，这导致线程块中的线程数是有限制的，现代GPUs的线程块可支持的线程数可达<strong>1024</strong>个。有时候，我们要知道一个线程在blcok中的全局ID，此时就必须还要知道block的组织结构，这是通过线程的内置变量blockDim来获得。它获取线程块各个维度的大小。对于一个2-dim的block(Dx,Dy)，线程(x,y)(x,y)的ID值为(x+y∗Dx)，如果是3-dim的block(Dx,Dy,Dz)，线程(x,y,z)的ID值为(x+y∗Dx+z∗Dx∗Dy)。另外线程还有内置变量gridDim，用于获得网格块各个维度的大小。</p><p>kernel的这种线程组织结构天然适合vector,matrix等运算，如我们将利用上图2-dim结构实现两个矩阵的加法，每个线程负责处理每个位置的两个元素相加，代码如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kernel定义</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">MatAdd</span><span class="params">(<span class="keyword">float</span> A[N][N], <span class="keyword">float</span> B[N][N], <span class="keyword">float</span> C[N][N])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x; </span><br><span class="line">    <span class="keyword">int</span> j = blockIdx.y * blockDim.y + threadIdx.y; </span><br><span class="line">    <span class="keyword">if</span> (i &lt; N &amp;&amp; j &lt; N) </span><br><span class="line">        C[i][j] = A[i][j] + B[i][j]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Kernel 线程配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">threadsPerBlock</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>; </span><br><span class="line">    <span class="function">dim3 <span class="title">numBlocks</span><span class="params">(N / threadsPerBlock.x, N / threadsPerBlock.y)</span></span>;</span><br><span class="line">    <span class="comment">// kernel调用</span></span><br><span class="line">    MatAdd&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A, B, C); </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="物理层次"><a href="#物理层次" class="headerlink" title="物理层次"></a>物理层次</h3><p>一个kernel实际上会启动很多线程，这些线程是逻辑上并行的，但是在物理层却并不一定。这其实和CPU的多线程有类似之处，多线程如果没有多核支持，在物理层也是无法实现并行的。但是好在GPU存在很多CUDA核心，充分利用CUDA核心可以充分发挥GPU的并行计算能力。</p><p>GPU硬件的一个核心组件是SM，SM的核心组件包括CUDA核心，共享内存，寄存器等，SM可以并发地执行数百个线程，并发能力就取决于SM所拥有的资源数。当一个kernel被执行时，它的gird中的线程块被分配到SM上，一个线程块只能在一个SM上被调度。SM一般可以调度多个线程块，这要看SM本身的能力。<strong>可能一个kernel的各个线程块被分配到多个SM中执行</strong>，grid只是逻辑层，而SM才是执行的物理层。</p><p>SM采用的是SIMT (Single-Instruction, Multiple-Thread，单指令多线程)架构，基本的执行单元是线程束（wraps)，1个线程束包含32个线程，这些线程同时执行相同的指令，但是每个线程都包含自己的指令地址计数器和寄存器状态，也有自己独立的执行路径。所以尽管线程束中的线程同时从同一程序地址执行，但是可能具有不同的行为，比如遇到了分支结构，一些线程可能进入这个分支，但是另外一些有可能不执行，它们只能死等，因为<strong>GPU规定线程束中所有线程在同一周期执行相同的指令</strong>，<strong>线程束分化会导致性能下降</strong>。当线程块被划分到某个SM上时，它将进一步划分为多个线程束，因为这才是SM的基本执行单元。SM要为每个线程块分配共享内存，也要为每个线程束中的线程分配独立的寄存器。所以SM的配置会影响其所支持的线程块和线程束并发数量。</p><p>在进行CUDA编程前，可以先检查一下自己的GPU的硬件配置，这样才可以有的放矢，可以通过下面的程序获得GPU的配置属性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dev = <span class="number">0</span>;</span><br><span class="line">cudaDeviceProp devProp;</span><br><span class="line">CHECK(cudaGetDeviceProperties(&amp;devProp, dev));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"使用GPU device "</span> &lt;&lt; dev &lt;&lt; <span class="string">": "</span> &lt;&lt; devProp.name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"SM的数量："</span> &lt;&lt; devProp.multiProcessorCount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"每个线程块的共享内存大小："</span> &lt;&lt; devProp.sharedMemPerBlock / <span class="number">1024.0</span> &lt;&lt; <span class="string">" KB"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"每个线程块的最大线程数："</span> &lt;&lt; devProp.maxThreadsPerBlock &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"每个SM的最大线程数："</span> &lt;&lt; devProp.maxThreadsPerMultiProcessor &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"每个SM的最大线程束数："</span> &lt;&lt; devProp.maxThreadsPerMultiProcessor / <span class="number">32</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line">使用GPU device <span class="number">0</span>: GeForce GT <span class="number">730</span></span><br><span class="line">SM的数量：<span class="number">2</span></span><br><span class="line">每个线程块的共享内存大小：<span class="number">48</span> KB</span><br><span class="line">每个线程块的最大线程数：<span class="number">1024</span></span><br><span class="line">每个SM的最大线程数：<span class="number">2048</span></span><br><span class="line">每个SM的最大线程束数：<span class="number">64</span></span><br></pre></td></tr></table></figure><p>总之，网格和线程块只是逻辑划分，一个kernel的所有线程其实在物理层是不一定同时并发的。所以kernel的grid和block的配置不同，性能会出现差异，这点是要特别注意的。还有，由于SM的基本执行单元是包含32个线程的线程束，所以block大小一般要设置为32的倍数。</p><h2 id="CUDA-API"><a href="#CUDA-API" class="headerlink" title="CUDA API"></a>CUDA API</h2><p>CUDA有两种类型API，一种是运行时API，一种是CUDA驱动API。运行时API是高层次封装，前缀是cuda，如cudaMalloc函数，用起来比较方便。驱动API控制能力较强，但也较难编程和调试，前缀是cu，如cuMalloc，功能与cudaMalloc类似。API之间没有明显的性能差异。</p><p>It is composed of two APIs:</p><ul><li>A low-level API called the CUDA driver API,</li><li>A higher-level API called the CUDA runtime API that is implemented on top of<br>the CUDA driver API.</li></ul><p>These APIs are mutually exclusive: An application should use either one or the other. API相互排斥，只能选用一种</p><p>The CUDA runtime eases device code management by providing implicit initialization, context management, and module management. The C host code generated by nvcc is based on the CUDA runtime (see Section 4.2.5), so  applications that link to this code must use the CUDA runtime API. 用NVCC编译的源码都应用cuda运行时API</p><p>In contrast, the CUDA driver API requires more code, is harder to program and debug, but offers a better level of control and is language-independent since it only deals with cubin objects (see Section 4.2.5). In particular, it is more difficult to<br> configure and launch kernels using the CUDA driver API, since the execution configuration and kernel parameters must be specified with explicit function calls instead of the execution configuration syntax described in Section 4.2.3. Also, device emulation (see Section 4.5.2.9) does not work with the CUDA driver API. </p><p>CUDA驱动API更难用，这也是为什么会提供CUDA运行时API的原因，但驱动API也有用武之地，比如设备仿真，运行时API就做不了，只能使用驱动API。</p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h3><p>同一个网格上的线程共享相同的全局内存空间，如下图所示。可以看到，每个线程有自己的私有本地内存（Local Memory），而每个线程块有包含共享内存（Shared Memory）,可以被线程块中所有线程共享，其生命周期与线程块一致。此外，所有的线程都可以访问全局内存（Global Memory）。还可以访问一些只读内存块：常量内存（Constant Memory）和纹理内存（Texture Memory）。内存结构涉及到程序优化。</p><p><img src="/images/CUDA-memory-model.jpg" alt="CUDA内存模型"></p><h3 id="内存管理API"><a href="#内存管理API" class="headerlink" title="内存管理API"></a>内存管理API</h3><p>在device上分配内存的cudaMalloc函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和C语言中的malloc类似，但是在device上申请一定字节大小的显存，其中devPtr是指向所分配内存的指针</span></span><br><span class="line"><span class="comment">// 释放分配的内存使用cudaFree函数，这和C语言中的free函数对应</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaMalloc</span><span class="params">(<span class="keyword">void</span>** devPtr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>负责host和device之间数据通信的cudaMemcpy函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMemcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> count, cudaMemcpyKind kind)</span></span></span><br></pre></td></tr></table></figure><p>其中src指向数据源，而dst是目标区域，count是复制的字节数，其中kind控制复制的方向：cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost及cudaMemcpyDeviceToDevice，如cudaMemcpyHostToDevice将host上数据拷贝到device上。</p><p>现在我们来实现一个向量加法的实例，这里grid和block都设计为1-dim，首先定义kernel如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个向量加法kernel，grid和block均为一维</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span>* x, <span class="keyword">float</span> * y, <span class="keyword">float</span>* z, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取全局索引</span></span><br><span class="line">    <span class="keyword">int</span> index = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="comment">// 步长</span></span><br><span class="line">    <span class="keyword">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; n; i += stride)</span><br><span class="line">    &#123;</span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中stride是整个grid的线程数，有时候向量的元素数很多，这时候可以将在每个线程实现多个元素（元素总数/线程总数）的加法，相当于使用了多个grid来处理，这是一种grid-stride loop方式，不过下面的例子一个线程只处理一个元素，所以kernel里面的循环是不执行的。下面我们具体实现向量加法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> nBytes = N * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    <span class="comment">// 申请host内存</span></span><br><span class="line">    <span class="keyword">float</span> *x, *y, *z;</span><br><span class="line">    x = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">    y = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">    z = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="number">10.0</span>;</span><br><span class="line">        y[i] = <span class="number">20.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请device内存</span></span><br><span class="line">    <span class="keyword">float</span> *d_x, *d_y, *d_z;</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_x, nBytes);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_y, nBytes);</span><br><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;d_z, nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将host数据拷贝到device</span></span><br><span class="line">    cudaMemcpy((<span class="keyword">void</span>*)d_x, (<span class="keyword">void</span>*)x, nBytes, cudaMemcpyHostToDevice);</span><br><span class="line">    cudaMemcpy((<span class="keyword">void</span>*)d_y, (<span class="keyword">void</span>*)y, nBytes, cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="comment">// 定义kernel的执行配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">blockSize</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">gridSize</span><span class="params">((N + blockSize.x - <span class="number">1</span>) / blockSize.x)</span></span>;</span><br><span class="line">    <span class="comment">// 执行kernel</span></span><br><span class="line">    add&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(d_x, d_y, d_z, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将device得到的结果拷贝到host</span></span><br><span class="line">    cudaMemcpy((<span class="keyword">void</span>*)z, (<span class="keyword">void</span>*)d_z, nBytes, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查执行结果</span></span><br><span class="line">    <span class="keyword">float</span> maxError = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        maxError = fmax(maxError, <span class="built_in">fabs</span>(z[i] - <span class="number">30.0</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"最大误差: "</span> &lt;&lt; maxError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放device内存</span></span><br><span class="line">    cudaFree(d_x);</span><br><span class="line">    cudaFree(d_y);</span><br><span class="line">    cudaFree(d_z);</span><br><span class="line">    <span class="comment">// 释放host内存</span></span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="built_in">free</span>(y);</span><br><span class="line">    <span class="built_in">free</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们的向量大小为1&lt;&lt;20(2^20)，而block大小为256(2^8)，那么grid大小是4096(2^12)，kernel的线程层级结构如下图所示：<br><img src="/images/kernel%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg" alt="kernel的线程层次结构"></p><p>使用nvprof工具可以分析kernel运行情况，结果如下所示，可以看到kernel函数费时约1.5ms。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nvprof cuda9.exe</span><br><span class="line">==7244== NVPROF is profiling process 7244, <span class="built_in">command</span>: cuda9.exe</span><br><span class="line">最大误差: 4.31602e+008</span><br><span class="line">==7244== Profiling application: cuda9.exe</span><br><span class="line">==7244== Profiling result:</span><br><span class="line">            Type  Time(%)      Time     Calls       Avg       Min       Max  Name</span><br><span class="line"> GPU activities:   67.57%  3.2256ms         2  1.6128ms  1.6017ms  1.6239ms  [CUDA memcpy HtoD]</span><br><span class="line">                   32.43%  1.5478ms         1  1.5478ms  1.5478ms  1.5478ms  add(<span class="built_in">float</span>*, <span class="built_in">float</span>*, <span class="built_in">float</span>*, int)</span><br></pre></td></tr></table></figure><p>调整block的大小，对比不同配置下的kernel运行情况，这里测试的是当block为128时，kernel费时约1.6ms，而block为512时kernel费时约1.7ms，当block为64时，kernel费时约2.3ms。看来不是block越大越好，而要适当选择。</p><p>在上面的实现中，我们需要单独在host和device上进行内存分配，并且要进行数据拷贝，这是很容易出错的。好在CUDA 6.0引入统一内存（Unified Memory）来避免这种麻烦，简单来说就是统一内存使用一个托管内存来共同管理host和device中的内存，并且<font color="red">自动在host和device中进行数据传输</font>。CUDA中使用cudaMallocManaged函数分配托管内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果数据仅需要放在CPU则无需用此函数</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">cudaMallocManaged</span><span class="params">(<span class="keyword">void</span> **devPtr, <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> flag=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>利用统一内存，可以将上面的程序简化如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> nBytes = N * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);<span class="comment">// 申请托管内存</span></span><br><span class="line">    <span class="keyword">float</span> *x, *y, *z;</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;x, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;y, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;z, nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] = <span class="number">10.0</span>;</span><br><span class="line">        y[i] = <span class="number">20.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义kernel的执行配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">blockSize</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">gridSize</span><span class="params">((N + blockSize.x - <span class="number">1</span>) / blockSize.x)</span></span>;</span><br><span class="line">    <span class="comment">// 执行kernel</span></span><br><span class="line">    add &lt;&lt; &lt; gridSize, blockSize &gt;&gt; &gt;(x, y, z, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步device 保证结果能正确访问</span></span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">    <span class="comment">// 检查执行结果</span></span><br><span class="line">    <span class="keyword">float</span> maxError = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        maxError = fmax(maxError, <span class="built_in">fabs</span>(z[i] - <span class="number">30.0</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"最大误差: "</span> &lt;&lt; maxError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    cudaFree(x);</span><br><span class="line">    cudaFree(y);</span><br><span class="line">    cudaFree(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之前的代码，使用统一内存更简洁了，值得注意的是kernel执行是与host异步的，由于托管内存自动进行数据传输，这里要用cudaDeviceSynchronize()函数保证device和host同步，这样后面才可以正确访问kernel计算的结果。</p><h2 id="矩阵乘法实例"><a href="#矩阵乘法实例" class="headerlink" title="矩阵乘法实例"></a>矩阵乘法实例</h2><p>最后我们再实现一个稍微复杂一些的例子，就是两个矩阵的乘法，设输入矩阵为A和B，要得到C=A×B。实现思路是每个线程计算C的一个元素值$$C_{i,j}$$，对于矩阵运算，应该选用grid和block为2-D的。首先定义矩阵的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩阵类型，行优先，M(row, col) = *(M.elements + row * M.width + col)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">float</span> *elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现矩阵乘法的核函数，这里我们定义了两个辅助的<code>__device__</code>函数分别用于获取矩阵的元素值和为矩阵元素赋值，具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 获取矩阵A的(row, col)元素</span></span><br><span class="line">__<span class="function">device__ <span class="keyword">float</span> <span class="title">getElement</span><span class="params">(Matrix *A, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A-&gt;elements[row * A-&gt;width + col];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为矩阵A的(row, col)元素赋值</span></span><br><span class="line">__<span class="function">device__ <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(Matrix *A, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">float</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A-&gt;elements[row * A-&gt;width + col] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵相乘kernel，2-D，每个线程计算一个元素</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">matMulKernel</span><span class="params">(Matrix *A, Matrix *B, Matrix *C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> Cvalue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> row = threadIdx.y + blockIdx.y * blockDim.y;</span><br><span class="line">    <span class="keyword">int</span> col = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A-&gt;width; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Cvalue += getElement(A, row, i) * getElement(B, i, col);</span><br><span class="line">    &#125;</span><br><span class="line">    setElement(C, row, col, Cvalue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们采用统一内存编写矩阵相乘的测试实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    Matrix *A, *B, *C;</span><br><span class="line">    <span class="comment">// 申请托管内存</span></span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;A, <span class="keyword">sizeof</span>(Matrix));</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;B, <span class="keyword">sizeof</span>(Matrix));</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;C, <span class="keyword">sizeof</span>(Matrix));</span><br><span class="line">    <span class="keyword">int</span> nBytes = width * height * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;A-&gt;elements, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;B-&gt;elements, nBytes);</span><br><span class="line">    cudaMallocManaged((<span class="keyword">void</span>**)&amp;C-&gt;elements, nBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    A-&gt;height = height;</span><br><span class="line">    A-&gt;width = width;</span><br><span class="line">    B-&gt;height = height;</span><br><span class="line">    B-&gt;width = width;</span><br><span class="line">    C-&gt;height = height;</span><br><span class="line">    C-&gt;width = width;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width * height; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A-&gt;elements[i] = <span class="number">1.0</span>;</span><br><span class="line">        B-&gt;elements[i] = <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义kernel的执行配置</span></span><br><span class="line">    <span class="function">dim3 <span class="title">blockSize</span><span class="params">(<span class="number">32</span>, <span class="number">32</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">gridSize</span><span class="params">((width + blockSize.x - <span class="number">1</span>) / blockSize.x, </span></span></span><br><span class="line"><span class="function"><span class="params">        (height + blockSize.y - <span class="number">1</span>) / blockSize.y)</span></span>;</span><br><span class="line">    <span class="comment">// 执行kernel</span></span><br><span class="line">    matMulKernel&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(A, B, C);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步device 保证结果能正确访问</span></span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">    <span class="comment">// 检查执行结果</span></span><br><span class="line">    <span class="keyword">float</span> maxError = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; width * height; ++i)</span><br><span class="line">        maxError = fmax(maxError, <span class="built_in">fabs</span>(C-&gt;elements[i] - <span class="number">2</span> * width));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"最大误差: "</span> &lt;&lt; maxError &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里矩阵大小为1024×10241024×1024，设计的线程的block大小为(32, 32)，那么grid大小为(32, 32)，最终测试结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nvprof cuda9.exe</span><br><span class="line">==16304== NVPROF is profiling process 16304, <span class="built_in">command</span>: cuda9.exe</span><br><span class="line">最大误差: 0</span><br><span class="line">==16304== Profiling application: cuda9.exe</span><br><span class="line">==16304== Profiling result:</span><br><span class="line">            Type  Time(%)      Time     Calls       Avg       Min       Max  Name</span><br><span class="line"> GPU activities:  100.00%  1.32752s         1  1.32752s  1.32752s  1.32752s  matMulKernel(Matrix*, Matrix*, Matrix*)</span><br><span class="line">      API calls:   83.11%  1.32762s         1  1.32762s  1.32762s  1.32762s  cudaDeviceSynchronize</span><br><span class="line">                   13.99%  223.40ms         6  37.233ms  37.341us  217.66ms  cudaMallocManaged</span><br><span class="line">                    2.81%  44.810ms         1  44.810ms  44.810ms  44.810ms  cudaLaunch</span><br><span class="line">                    0.08%  1.3300ms        94  14.149us       0ns  884.64us  cuDeviceGetAttribute</span><br><span class="line">                    0.01%  199.03us         1  199.03us  199.03us  199.03us  cuDeviceGetName</span><br><span class="line">                    0.00%  10.009us         1  10.009us  10.009us  10.009us  cuDeviceTotalMem</span><br><span class="line">                    0.00%  6.5440us         1  6.5440us  6.5440us  6.5440us  cudaConfigureCall</span><br><span class="line">                    0.00%  3.0800us         3  1.0260us     385ns  1.5400us  cudaSetupArgument</span><br><span class="line">                    0.00%  2.6940us         3     898ns     385ns  1.5390us  cuDeviceGetCount</span><br><span class="line">                    0.00%  1.9250us         2     962ns     385ns  1.5400us  cuDeviceGet</span><br><span class="line"></span><br><span class="line">==16304== Unified Memory profiling result:</span><br><span class="line">Device <span class="string">"GeForce GT 730 (0)"</span></span><br><span class="line">   Count  Avg Size  Min Size  Max Size  Total Size  Total Time  Name</span><br><span class="line">    2051  4.0000KB  4.0000KB  4.0000KB  8.011719MB  21.20721ms  Host To Device</span><br><span class="line">     270  45.570KB  4.0000KB  1.0000MB  12.01563MB  7.032508ms  Device To Host</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/xiaohu2022/article/details/79599947" target="_blank" rel="noopener">https://blog.csdn.net/xiaohu2022/article/details/79599947</a></li><li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html" target="_blank" rel="noopener">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计原则（2）：里氏替换原则</title>
      <link href="/design_patterns/LSP_Liskov_Substitution_Principle%20.html"/>
      <url>/design_patterns/LSP_Liskov_Substitution_Principle%20.html</url>
      
        <content type="html"><![CDATA[<p>里氏替换原则(Liskov Substitution Principle，LSP)是面向对象设计的基本原则之一，最早于1988年由麻省理工学院 Barbara Liskov 女士（里氏）提出。LSP是继承复用的基石，只有当派生类可以替换掉基类，软件单位的功能不改变时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p><p>定义2：所有引用基类的地方必须能透明地使用其子类的对象。</p><h3 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h3><p>有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>完成一个两数相减的功能，由类A来负责。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">System.out.println(<span class="string">"100-50="</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">System.out.println(<span class="string">"100-80="</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100-50=50</span><br><span class="line">100-80=20</span><br></pre></td></tr></table></figure><p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p><ol><li>两数相减。</li><li>两数相加，然后再加100。</li></ol><p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">System.out.println(<span class="string">"100-50="</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">System.out.println(<span class="string">"100-80="</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">System.out.println(<span class="string">"100+20+100="</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类B完成后，运行结果：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span><span class="number">-50</span>=<span class="number">150</span></span><br><span class="line"><span class="number">100</span><span class="number">-80</span>=<span class="number">180</span></span><br><span class="line"><span class="number">100</span>+<span class="number">20</span>+<span class="number">100</span>=<span class="number">220</span></span><br></pre></td></tr></table></figure><p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？后果就是：你写的代码出问题的几率将会大大增加。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.uml.org.cn/sjms/201211023.asp" target="_blank" rel="noopener">http://www.uml.org.cn/sjms/201211023.asp</a></li><li><a href="https://baike.baidu.com/item/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/3744239?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/3744239?fr=aladdin</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 原则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之import</title>
      <link href="/Python/python_import.html"/>
      <url>/Python/python_import.html</url>
      
        <content type="html"><![CDATA[<h2 id="模块导入的两种方式"><a href="#模块导入的两种方式" class="headerlink" title="模块导入的两种方式"></a>模块导入的两种方式</h2><ul><li>使用<strong>点</strong>的方式可以导入，但是不能直接运行。</li><li>使用<strong>根目录名称</strong>导入，需要有<code>__init__.py</code>文件，否则不认为文件夹名是一个包</li></ul><h2 id="模块引用的顺序"><a href="#模块引用的顺序" class="headerlink" title="模块引用的顺序"></a>模块引用的顺序</h2><p>import时首先判断这个module是不是built-in即内建模块，比如import sys。如果是，则引入内建模块；如果不是，则在一个称为sys.path的list中寻找。sys.path在python脚本执行时动态生成，包括以下4个部分： </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.脚本执行的位置，即运行模块的路径 （顺序第一）</span><br><span class="line"><span class="number">2</span>.环境变量中的PYTHONPATH, 即<span class="selector-class">.bash_profile</span> （顺序第二）</span><br><span class="line"><span class="number">3</span>.第三方模块的位置，一般在site-package文件夹下 （顺序第三）</span><br><span class="line"><span class="number">4</span>.通过sys<span class="selector-class">.path</span><span class="selector-class">.append</span>(path)添加到sys.path中的路径 （顺序第四）</span><br></pre></td></tr></table></figure><p>可以看到脚本执行的位置是位于第一优先级的。</p><p>查看python模块查找路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.path)</span><br></pre></td></tr></table></figure><h2 id="循环导入问题"><a href="#循环导入问题" class="headerlink" title="循环导入问题"></a>循环导入问题</h2><p>一般错误提示：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: cannot <span class="keyword">import</span> <span class="keyword">name</span> xxx</span><br></pre></td></tr></table></figure><p>循环导入的例子：</p><p>Main:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> entity <span class="keyword">import</span> Ent<span class="comment"># 1 从entity导入Ent类</span></span><br></pre></td></tr></table></figure><p>Entity:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> physics <span class="keyword">import</span> Physics<span class="comment"># 2 从physics导入Physics类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ent</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>Physics:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> entity <span class="keyword">import</span> Ent<span class="comment"># 3 这里发生了循环导入，Physics类实际上先于Ent类初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Physics</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>I then run from main.py and I get the following error:</p><blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; Traceback (most recent call last):</span><br><span class="line">&gt; File <span class="string">"main.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">&gt;  <span class="keyword">from</span> entity <span class="keyword">import</span> Ent</span><br><span class="line">&gt; File <span class="string">".../entity.py"</span>, line <span class="number">5</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">&gt;  <span class="keyword">from</span> physics <span class="keyword">import</span> Physics</span><br><span class="line">&gt; File <span class="string">".../physics.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">&gt;  <span class="keyword">from</span> entity <span class="keyword">import</span> Ent</span><br><span class="line">&gt; ImportError: cannot <span class="keyword">import</span> name Ent</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>You have circular dependent imports. <code>physics.py</code> is imported from <code>entity</code> before class <code>Ent</code> is defined and <code>physics</code> tries to import <code>entity</code> that is already initializing. Remove the dependency to <code>physics</code> from <code>entity</code> module.</p><p>循环导入属于设计问题，无法通过合理安排导入顺序解决，必须重新设计，移除<code>physics</code> 对 <code>entity</code> 模块依赖。</p><h2 id="导入顺序问题"><a href="#导入顺序问题" class="headerlink" title="导入顺序问题"></a>导入顺序问题</h2><p>导入顺序问题可以通过合理安排导入顺序解决，不属于设计问题，较好解决。</p><p>一般错误提示：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: <span class="built_in">module</span> <span class="string">'xxx'</span> has <span class="literal">no</span> attribute <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure><p>例子</p><p><code>cvtools.__init__.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...省略若干非核心代码</span></span><br><span class="line"><span class="keyword">from</span> .evaluation <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> .ops <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p><code>cvtools.ops.__init__.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .nms <span class="keyword">import</span> py_cpu_nms</span><br><span class="line">__all__ = [<span class="string">'py_cpu_nms'</span>]</span><br></pre></td></tr></table></figure><p><code>cvtools.evaluation.merge_dets.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...省略若干非核心代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeCropDetResults</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nms_method=cvtools.py_cpu_nms, nms_th=<span class="number">0.15</span>)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>py_cpu_nms还没导入就在merge_dets模块使用了，因此报AttributeError。需将ops的导入调到evaluation导入前。本例举的是写cvtools库过程犯的小错误，cvtools的<a href="https://github.com/gfjiangly/cvtools" target="_blank" rel="noopener">GitHub代码</a>是没有这种问题。</p><p>原则：</p><ul><li>一般将低依赖的模块放在靠前的位置导入，因为它的依赖较少</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy之条件筛选</title>
      <link href="/Python/numpy_conditional_filtering.html"/>
      <url>/Python/numpy_conditional_filtering.html</url>
      
        <content type="html"><![CDATA[<p>筛选用错了，后果很严重！</p><h2 id="特定值筛选"><a href="#特定值筛选" class="headerlink" title="特定值筛选"></a>特定值筛选</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当数组是一维数组时，返回的值是一维的索引，所以只有一组索引数组</span></span><br><span class="line">arr = np.array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">134</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">546</span>, <span class="number">1</span>])</span><br><span class="line">print(np.where(arr == <span class="number">3</span>))<span class="comment"># 索引，注意返回的是元组，里面有一个元素</span></span><br><span class="line">print(arr[np.where(arr == <span class="number">3</span>)])<span class="comment"># 值</span></span><br><span class="line"><span class="comment"># 当数组是二维数组时，满足条件的数组值返回的是值的位置索引，因此会有两组索引数组来表示值的位置，返回的第一个array表示行坐标，第二个array表示纵坐标，两者一一对应</span></span><br><span class="line">arr = np.array([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">134</span>], [<span class="number">45</span>, <span class="number">3</span>, <span class="number">546</span>, <span class="number">1</span>]])</span><br><span class="line">print(np.where(arr == <span class="number">1</span>))<span class="comment"># 索引，注意返回的是元组，里面有两个元素</span></span><br><span class="line">print(arr[np.where(arr == <span class="number">1</span>)])<span class="comment"># 值</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(array([5]),)</span><br><span class="line">[3]</span><br><span class="line">(array([0, 0, 0]), array([0, 1, 2]))</span><br><span class="line">[1 1 1]</span><br></pre></td></tr></table></figure><p>Notes: </p><ul><li>np.where返回的是元组</li><li>元组元素数与筛选的数组维度相关</li></ul><h2 id="多个固定值筛选"><a href="#多个固定值筛选" class="headerlink" title="多个固定值筛选"></a>多个固定值筛选</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">134</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">546</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">print(np.where((arr == <span class="number">3</span>) | (arr == <span class="number">1</span>)))</span><br><span class="line">print(arr[np.where((arr == <span class="number">3</span>) | (arr == <span class="number">1</span>))])</span><br></pre></td></tr></table></figure><h2 id="范围筛选"><a href="#范围筛选" class="headerlink" title="范围筛选"></a>范围筛选</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">134</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">546</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">print(np.where(arr &gt; <span class="number">3</span>))</span><br><span class="line">print(arr[np.where(arr &gt; <span class="number">3</span>)])</span><br></pre></td></tr></table></figure><p>如果不需要index，还可以有更快的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">134</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">546</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">print(arr[arr &gt; <span class="number">3</span>])</span><br></pre></td></tr></table></figure><h2 id="多范围筛选"><a href="#多范围筛选" class="headerlink" title="多范围筛选"></a>多范围筛选</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">134</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">546</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">print(arr[(arr &gt; <span class="number">1</span>]) &amp; (arr &lt; <span class="number">200</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy常见的使用错误</title>
      <link href="/Python/common_usage_errors_numpy.html"/>
      <url>/Python/common_usage_errors_numpy.html</url>
      
        <content type="html"><![CDATA[<p>本页面持续更新…</p><h2 id="空数组拼接问题"><a href="#空数组拼接问题" class="headerlink" title="空数组拼接问题"></a>空数组拼接问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line"><span class="comment"># ValueError: all the input array dimensions except for the concatenation axis must match exactly</span></span><br><span class="line">np.vstack([np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]]), np.array([])])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line">np.vstack([np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]]), np.empty((<span class="number">0</span>, <span class="number">2</span>))])</span><br></pre></td></tr></table></figure><p>上面诡异的表现与numpy版本有关，我记得在1.15.x版本，第一种写法也是对的，但是今天发现在1.16.4版本就提示错误了。GitHub的numpy仓库下有相关<a href="https://github.com/numpy/numpy/issues/12628" target="_blank" rel="noopener">issure</a>。</p><h2 id="从list创建array"><a href="#从list创建array" class="headerlink" title="从list创建array"></a>从list创建array</h2><ul><li>深复制list中数据</li><li>长度不同的二级或更多级list创建非数值对象，numpy直接将list保存成其data</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]]</span><br><span class="line">data_array = np.array(data_list)</span><br><span class="line"><span class="comment"># data_array.dtype为object</span></span><br><span class="line">data_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">data_array = np.array(data_list)</span><br><span class="line">data_array[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># data_list[0][0]还是1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask服务连接错误</title>
      <link href="/Python/flask_connection_error.html"/>
      <url>/Python/flask_connection_error.html</url>
      
        <content type="html"><![CDATA[<h2 id="记一次诡异的错误"><a href="#记一次诡异的错误" class="headerlink" title="记一次诡异的错误"></a>记一次诡异的错误</h2><p>运行Flask web服务，客户端请求一直出现下面的连接错误</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests.exceptions.ConnectionError: <span class="constructor">HTTPConnectionPool(<span class="params">host</span>='<span class="params">ip</span>', <span class="params">port</span>=666)</span>: Max retries exceeded <span class="keyword">with</span> url: /detect_hat (Caused by <span class="constructor">NewConnectionError('&lt;<span class="params">urllib3</span>.<span class="params">connection</span>.HTTPConnection <span class="params">object</span> <span class="params">at</span> 0x000001A4FFB50390&gt;: Failed <span class="params">to</span> <span class="params">establish</span> <span class="params">a</span> <span class="params">new</span> <span class="params">connection</span>: [WinError 10061] 由于目标计算机积极拒绝，无法连接。')</span>)</span><br></pre></td></tr></table></figure><p>今晚L同学突然要我和他一起调试一个Web服务，原因是最近他那边请求时不时会返回500错误，需要我这边打断点，看看他那边发来的数据有没有问题。我的服务部署在docker中，666映射到5000端口，因此服务的请求URL类似于</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//ip:666/service_name</span></span><br></pre></td></tr></table></figure><p>5000是flask服务的默认使用端口，我没修改，采用docker映射这个端口好记一些。L同学要调试，因此我使用了我的本地代码同步到docker上调试，但是我的本地代码flask服务的端口直接使用的是666端口，因为开发环境当时没用docker。将主机的666端口映射到docker容器内的666端口，才没有出现上面的连接错误。其实不止端口错了会出现连接错误，未开启服务也会出现连接错误。</p><h2 id="刷锅"><a href="#刷锅" class="headerlink" title="刷锅"></a>刷锅</h2><p>我问L同学这个错误熟不熟，遇没遇到？L同学居然说没遇到！我记忆中对这个错误是有印象的，因为有次我的服务停了，L同学访问了这个服务，然后就遇到了这个连接错误，然后让我看看，然后就发现服务停了，所以他应该比我更熟悉！端口号使用错误可以从两个角度理解，一是客户端用错了，二是服务器端部署错了。如果不是容器内端口容器外访问不到，除非做了主机端口映射，不然又可以甩锅L同学客户端写错端口号了。看来这个锅必须自己接啦，还好问题不大。这种问题其实是知道出现在网络的某个环节，因为客户端程序之前是可以跑的，服务器端服务也在正常运行，也没设置什么拦截之类，只要认真梳理访问的每一个环节，肯定能发现问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>出现了连接错误，不仅要检查IP是否正确，还要检查端口是否正确</li><li>不仅要检查flask使用的端口是否正确，还要检查是否与docker映射的端口匹配</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CICD介绍</title>
      <link href="/cicd/cicd_introduction.html"/>
      <url>/cicd/cicd_introduction.html</url>
      
        <content type="html"><![CDATA[<h2 id="CICD流程"><a href="#CICD流程" class="headerlink" title="CICD流程"></a>CICD流程</h2><p> CICD的中文名为持续集成/持续部署。其流程如下图：</p><p><img src="/images/166a9260db2ce221" alt="img"></p><h2 id="CICD的意义"><a href="#CICD的意义" class="headerlink" title="CICD的意义"></a>CICD的意义</h2><h3 id="减少重复过程"><a href="#减少重复过程" class="headerlink" title="减少重复过程"></a>减少重复过程</h3><p>减少重复的过程可以节省时间、费用和工作量。重复劳动可能包括代码编译、数据库集成、测试、审查、部署及反馈。通过自动化的持续集成可以将这些重复的动作都变成自动化的，无需太多人工干预，让人们的时间更多的投入到动脑筋的、更高价值的事情上。</p><h3 id="减少多人协作开发的冲突"><a href="#减少多人协作开发的冲突" class="headerlink" title="减少多人协作开发的冲突"></a>减少多人协作开发的冲突</h3><p>当分支代码保持在<strong>取出状态时间越长</strong>，分支代码开发者进行主线重新集成时，就愈容易遭遇集成多重冲突的风险以及失败。当开发者将代码提交到代码库时，首先必须更新代码以反映别人在代码库中的更改。代码库包含的更改越多，开发人员在提交自己的更改前必须运行的工作越多。如果不经常进行集成，代码库将变的非常不同于开发者本地的代码，这时进入被称为合并地狱或集成地狱的阶段，开发者所花费的集成时间，将超过最初代码开发的时间。</p><h3 id="任何时间、任何地点都可以生成可部署的软件"><a href="#任何时间、任何地点都可以生成可部署的软件" class="headerlink" title="任何时间、任何地点都可以生成可部署的软件"></a>任何时间、任何地点都可以生成可部署的软件</h3><p>持续集成可以让您在任何时间发布可以部署的软件。从外界来看，这是持续集成最明显的好处，我们可以对改进软件品质和减少风险说起来滔滔不绝，但对于客户来说，可以部署的软件产品是最实际的资产。利用持续集成，您可以经常对源代码进行一些小改动，并将这些改动和其他的代码进行集成。如果出现问题，项目成员马上就会被通知到，问题会第一时间被修复。不采用持续集成的情况下，这些问题有可能到交付前的集成测试的时候才发现，有可能会导致延迟发布产品，而在急于修复这些缺陷的时候又有可能引入新的缺陷，最终可能导致项目失败。</p><p>这一点深有感悟，因为在实验室写代码，老师会经常问这个东西可以用了吗，可以用其实就是一个产品的概念。做好持续集成和持续部署，你可以随时和老师说这个东西可以用！</p><h2 id="开发一个Python包的CICD"><a href="#开发一个Python包的CICD" class="headerlink" title="开发一个Python包的CICD"></a>开发一个Python包的CICD</h2><p>持续集成，意味着每写一段代码都能通过测试，同时不影响其它模块正常运行（先前的测试依然要通过）。每个函数或类都要有其对应的测试代码。</p><p>持续部署，意味着将持续集成的代码构建成包上传到PYPI。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5bd130876fb9a05d2b6dfd23" target="_blank" rel="noopener">https://juejin.im/post/5bd130876fb9a05d2b6dfd23</a></li><li><a href="https://www.cnblogs.com/lyq863987322/p/8516958.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyq863987322/p/8516958.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> CICD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CICD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码覆盖测试</title>
      <link href="/coding/code_coverage_test.html"/>
      <url>/coding/code_coverage_test.html</url>
      
        <content type="html"><![CDATA[<p>代码覆盖（Code Coverage）是软件测试中的一种度量，描述源代码被测试的比例和程度，所得比例称为代码覆盖率。在做单元测试时，代码覆盖率常常被拿来作为衡量测试好坏的指标，甚至，用代码覆盖率来考核测试任务完成情况，比如，代码覆盖率必须达到80%或90%。于是乎，测试人员费尽心思设计案例覆盖代码。用代码覆盖率来衡量，有利也有弊。</p><h2 id="度量方式"><a href="#度量方式" class="headerlink" title="度量方式"></a>度量方式</h2><h3 id="函数覆盖"><a href="#函数覆盖" class="headerlink" title="函数覆盖"></a>函数覆盖</h3><p>函数覆盖（Function Coverage），执行到程序中的每一个函数（或副程式）。</p><h3 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h3><p>语句覆盖(Statement Coverage)，又称行覆盖(Line Coverage)，段覆盖(Segment Coverage)，基本块覆盖(Basic Block Coverage)，这是最常用也是最常见的一种覆盖方式，就是度量被测代码中每个可执行语句是否被执行到了。这里说的是“可执行语句”，因此就不会包括像C++的头文件声明，代码注释，空行，等等。非常好理解，只统计能够执行的代码被执行了多少行。需要注意的是，单独一行的花括号{}也常常被统计进去。语句覆盖常常被人指责为“最弱的覆盖”，它只管覆盖代码中的执行语句，却<strong>不考虑各种分支的组合</strong>等等。假如你的上司只要求你达到语句覆盖，那么你可以省下很多功夫，但是，换来的确实测试效果的不明显，很难更多地发现代码中的问题。</p><h3 id="判断覆盖"><a href="#判断覆盖" class="headerlink" title="判断覆盖"></a>判断覆盖</h3><p>判断覆盖(Decision Coverage)，又称分支覆盖(Branch Coverage)，所有边界覆盖(All-Edges Coverage)，基本路径覆盖(Basic Path Coverage)，判定路径覆盖(Decision-Decision-Path)。它度量程序中<strong>每一个判定的分支是否都被测试到</strong>。这句话是需要进一步理解的，应该非常容易和下面说到的条件覆盖混淆。</p><h3 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h3><p>条件覆盖(Condition Coverage)，它度量判定中的<strong>每个子表达式结果true和false是否被测试到</strong>。</p><h3 id="路径覆盖"><a href="#路径覆盖" class="headerlink" title="路径覆盖"></a>路径覆盖</h3><p>路径覆盖(Path Coverage)，又称断言覆盖(Predicate Coverage)。它度量了是否函数的每一个分支都被执行了。 这句话也非常好理解，就是所有可能的分支都执行一遍，有多个分支嵌套时，需要对多个分支进行排列组合，可想而知，测试路径随着分支的数量指数级别增加。</p><h2 id="代码覆盖测试工具"><a href="#代码覆盖测试工具" class="headerlink" title="代码覆盖测试工具"></a>代码覆盖测试工具</h2><h3 id="Codecov"><a href="#Codecov" class="headerlink" title="Codecov"></a>Codecov</h3><p>Codecov网站是一个开源的测试结果展示平台，将测试结果可视化。Github上许多开源项目都使用了Codecov来展示单测结果。Codecov只是代码覆盖测试报告托管平台，一般是与Travis CI、GitHub Action等工具集成。Travis CI或GitHub Action等可以建立覆盖测试环境，在其中安装如Python的coverage等包执行覆盖测试，然后生成代码覆盖测试报告，上传到Codecov。所以实际做覆盖测试的是coverage等具体工具包，而非网站。</p><h3 id="Python程序的覆盖测试"><a href="#Python程序的覆盖测试" class="headerlink" title="Python程序的覆盖测试"></a>Python程序的覆盖测试</h3><p>这里以coverage举例，也可使用pytest-cov。貌似只能做语句覆盖测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装覆盖测试的Python包</span></span><br><span class="line">pip install coverage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pytest做测试，使用coverage分析测试过程</span></span><br><span class="line">coverage run -m pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报告覆盖测试结果</span></span><br><span class="line">coverage report -m</span><br></pre></td></tr></table></figure><h3 id="使用Travis-CI构建环境、测试以及上传到Codecov"><a href="#使用Travis-CI构建环境、测试以及上传到Codecov" class="headerlink" title="使用Travis CI构建环境、测试以及上传到Codecov"></a>使用Travis CI构建环境、测试以及上传到Codecov</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dist:</span> <span class="string">xenial</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">python</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">rm</span> <span class="bullet">-rf</span> <span class="string">.eggs</span> <span class="string">&amp;&amp;</span> <span class="string">pip</span> <span class="string">install</span> <span class="bullet">-e</span> <span class="string">.</span> </span><br><span class="line"><span class="bullet">  -</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">pytest-cov</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">codecov</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  pip:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">python:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'3.5'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'3.6'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'3.7'</span></span><br><span class="line"><span class="attr">script:</span> <span class="string">python</span> <span class="bullet">-m</span> <span class="string">pytest</span> <span class="bullet">--cov=cvtools</span></span><br><span class="line"><span class="attr">after_success:</span> <span class="string">codecov</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/codecov/codecov-python" target="_blank" rel="noopener">codecov</a>包作用：Find coverage reports for all the languages ​​below, gather them and submit them to Codecov.</p><p>可见只是一个测试报告上传工具，GitHub上的源代码只有一个文件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的学习，我们再回头想想，覆盖率数据到底有多大意义。总结如下几个观点：</p><ul><li>覆盖率数据只能代表你测试过哪些代码，不能代表你是否测试好这些代码。</li><li>不要过于相信覆盖率数据。</li><li>不要只拿语句覆盖率(行覆盖率)来考核你的测试人员。</li><li>覆盖强弱：路径覆盖 &gt; 判定覆盖 &gt; 语句覆盖</li><li>测试人员不能盲目追求代码覆盖率，而应该想办法设计更多更好的案例，哪怕多设计出来的案例对覆盖率一点影响也没有。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之function</title>
      <link href="/Python/function.html"/>
      <url>/Python/function.html</url>
      
        <content type="html"><![CDATA[<p>Q1 函数是一等对象</p><p>A1 </p><ul><li>函数可以作为参数传递</li><li>可以返回函数</li><li>可以赋值给变量</li><li>其表现称得上对象</li></ul><p>Q2 函数的参数</p><p>A2 有位置参数、关键字参数（默认参数）、可变参数（元组参数， <code>*args</code> ）以及字典参数（ <code>**kargs</code> ）。其中元组参数和字典参数名称是我自己取的，网上各种叫法都有，我是根据其数据结构特点取名的。可变参数是指就是一个元组，里面可以存放0个或多个参数，使用<code>*</code>标志。字典参数是在Python3中新加的，其数据结构表现与字典类似，使用<code>**</code>标志。</p><p>Q3 传值还是传引用</p><p>A3 比较有争议，see: <a href="https://www.zhihu.com/question/20591688" target="_blank" rel="noopener">https://www.zhihu.com/question/20591688</a></p><p>我倾向于Python里面没有传值和传引用一说，因为Python没有这两个概念。如果我们从表现的像鸭子即可以认为是鸭子的观点看，对于不可变对象作为函数参数，相当于C++的值传递；对于可变对象作为函数参数，相当于C++的引用传递。但实际上这个理解非常肤浅。这个问题有关Python的名称绑定机制（name binding）。如果按名称绑定的观点看，传进去的就是一块函数外的数据，形参变量名称与这块数据绑定，没有数据被复制，可以认为是引用传递（但实际上又没有指针这个概念，所以讨论到底属于传值还是传引用是没有意义，有意义的地方在于理解参数传递过程以及名称绑定机制）</p><p>Python中变量是由<code>名称+数据</code>构成，如果使用一个仅有名称而无数据的变量（或许不该叫变量）会报NameError：name ‘xxx’ is not defined. 数据是有类型的而名称没有类型。名称和数据可以分离，这个过程必然伴随，名称与其它数据结合。而在C/C++这样的语言中名称是不能与数据分离的，名称即数据。</p><p>名称与数据的第一次绑定过程，即为名称的定义（名称的初始化）。类似于像<code>a, b = b, a</code>这样的变戏法就是一个名称的重新绑定过程，没有新的数据被创建，因此也不需要另外一个名称。如果从有没有新的数据被创建角度观察Python行为，也许很多疑惑就能解开，比如期待被修改的数据没有被修改，不期待修改的数据被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = a[<span class="number">1</span>]<span class="comment"># 没有新数据被创建，修改b也就修改了a</span></span><br><span class="line">c = &#123;<span class="string">'name'</span>: <span class="string">'jiang'</span>, <span class="string">'gender'</span>: <span class="string">'man'</span>, <span class="string">'index'</span>: <span class="number">0</span>&#125;</span><br><span class="line">d = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    c[<span class="string">'index'</span>] = i</span><br><span class="line">    d.append(c)</span><br><span class="line">print(d)<span class="comment"># d内的5个字典都相同，这是为什么呢？这是因为没有新的字典被创建</span></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">[&#123;<span class="string">'name'</span>: <span class="string">'jiang'</span>, <span class="string">'gender'</span>: <span class="string">'man'</span>, <span class="string">'index'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'jiang'</span>, <span class="string">'gender'</span>: <span class="string">'man'</span>, <span class="string">'index'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'jiang'</span>, <span class="string">'gender'</span>: <span class="string">'man'</span>, <span class="string">'index'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'jiang'</span>, <span class="string">'gender'</span>: <span class="string">'man'</span>, <span class="string">'index'</span>: <span class="number">4</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'jiang'</span>, <span class="string">'gender'</span>: <span class="string">'man'</span>, <span class="string">'index'</span>: <span class="number">4</span>&#125;]</span><br></pre></td></tr></table></figure><p>Q4 嵌套函数</p><p>A4 这是一个比较大的话题，主要讨论变量作用域</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之内建装饰器</title>
      <link href="/Python/build_decorator.html"/>
      <url>/Python/build_decorator.html</url>
      
        <content type="html"><![CDATA[<p>@property</p><p>将类的方法变成属性调用方式，相当于少了()</p><p>看起来具有迷惑性，例如，方法返回的是一个字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">module_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._module_dict</span><br></pre></td></tr></table></figure><p>调用：obj_type = registry.module_dict[obj_type]</p><p>看起来module_dict像一个字典一样，实际上它是一个方法，里面还可以完成其它动作。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的import</title>
      <link href="/Python/import.html"/>
      <url>/Python/import.html</url>
      
        <content type="html"><![CDATA[<p>import导入的两种方式</p><ul><li>使用<strong>点</strong>的方式可以导入，但是不能直接运行。</li><li>使用<strong>根目录名称</strong>导入，需要有<strong>init</strong>.py文件，否则不认为文件夹名是一个包</li></ul><p>python模块引用的顺序：</p><p>import引用时首先判断这个module是不是built-in即内建模块，比如import sys。如果是则引入内建模块，</p><p>如果不是则在一个称为sys.path的list中寻找（引用的时候会按照下面的顺序去引用）</p><p>sys.path在python脚本执行时动态生成，包括以下3个部分： </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.脚本执行的位置，即运行模块的路径 （顺序第一）</span><br><span class="line"><span class="number">2</span>.环境变量中的PYTHONPATH, 即<span class="selector-class">.bash_profile</span> （顺序第二）</span><br><span class="line"><span class="number">3</span>.第三方模块的位置，一般在site-package文件夹下 （顺序第三）</span><br><span class="line"><span class="number">4</span>.通过sys<span class="selector-class">.path</span><span class="selector-class">.append</span>(path)添加到sys.path中的路径 （顺序第四）</span><br></pre></td></tr></table></figure><p>可以看到脚本执行的位置是位于第一优先级的。</p><p>查看python模块查找路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.path)</span><br></pre></td></tr></table></figure><p>同名模块冲突问题：</p><p>cvtools与pycocotools</p><p>ImportError: cannot import name XXX</p><p>Main:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> entity <span class="keyword">import</span> Ent</span><br><span class="line"><span class="keyword">from</span> vector <span class="keyword">import</span> Vect</span><br><span class="line"><span class="comment">#the rest just creates an entity and prints the result of movement</span></span><br></pre></td></tr></table></figure><p>Entity:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> vector <span class="keyword">import</span> Vect</span><br><span class="line"><span class="keyword">from</span> physics <span class="keyword">import</span> Physics</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ent</span>:</span></span><br><span class="line">    <span class="comment">#holds vector information and id</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tick</span><span class="params">(self, dt)</span>:</span></span><br><span class="line">    <span class="comment">#this is where physics changes the velocity and position vectors</span></span><br></pre></td></tr></table></figure><p>Vector:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vect</span>:</span></span><br><span class="line">    <span class="comment">#holds i, j, k, and does vector math</span></span><br></pre></td></tr></table></figure><p>Physics:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> entity <span class="keyword">import</span> Ent</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Physics</span>:</span></span><br><span class="line">    <span class="comment">#physics class gets an entity and does physics calculations on it.</span></span><br></pre></td></tr></table></figure><p>I then run from main.py and I get the following error:</p><blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; Traceback (most recent call last):</span><br><span class="line">&gt; File <span class="string">"main.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">&gt;  <span class="keyword">from</span> entity <span class="keyword">import</span> Ent</span><br><span class="line">&gt; File <span class="string">".../entity.py"</span>, line <span class="number">5</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">&gt;  <span class="keyword">from</span> physics <span class="keyword">import</span> Physics</span><br><span class="line">&gt; File <span class="string">".../physics.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">&gt;  <span class="keyword">from</span> entity <span class="keyword">import</span> Ent</span><br><span class="line">&gt; ImportError: cannot <span class="keyword">import</span> name Ent</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>You have circular dependent imports. <code>physics.py</code> is imported from <code>entity</code> before class <code>Ent</code> is defined and <code>physics</code> tries to import <code>entity</code> that is already initializing. Remove the dependency to <code>physics</code> from <code>entity</code> module.</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之Hook设计</title>
      <link href="/Python/hook.html"/>
      <url>/Python/hook.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hook设计描述"><a href="#Hook设计描述" class="headerlink" title="Hook设计描述"></a>Hook设计描述</h2><p>hook，又称钩子，在C/C++中一般叫做回调函数。钩子是从功能角度描述这种编程模式，回调则是从函数调用时间角度描述的。通常理解的hook是在一个已有的方法上加入一些钩子，使得在该方法执行前或执行后另在做一些额外的处理。如我们熟知的windows系统消息响应事件，鼠标点击对程序产生的影响是有程序自己决定的，但是程序的执行是受制于框架（windows系统），框架提供了一些通用的流程执行，但是往往框架或流程在设计时无法完全预料到以后的使用会有什么新需求，或者有些行为只有在运行时才能确定的。这就产生了回调的需求，即用户提供需求，框架负责执行，流程先于具体需求，当触发或者满足某种条件时，执行Hook函数。hook函数的数据也是由用户自己提供的，框架只负责流程执行，这样框架的通用性就能大大提高。</p><h2 id="Hook设计三要素"><a href="#Hook设计三要素" class="headerlink" title="Hook设计三要素"></a>Hook设计三要素</h2><ul><li>hook函数或类：实现自定义操作或功能</li><li>注册：只有经过注册的Hook才能被系统或框架调用</li><li>挂载点：通常由系统或框架决定，用户无法修改</li></ul><h2 id="设计实例"><a href="#设计实例" class="headerlink" title="设计实例"></a>设计实例</h2><p>我们看看具体的设计实例：mmcv库的Run类。Run类负责训练流程执行，由用户提供的数据。</p><p>Hook类是所有hook类的父类，规定了具体的调用名称和挂载点，如before_run、before_epoch、after_epoch、after_run等，注册的hook类需要具体实现自己的需求，例如实现自定义的学习率更新策略，框架会在Run中每个挂载点循环执行用户注册的所有hooks的相应挂载点方法，用户hooks是放在一个有序列表中，按优先级排列，优先级高的在前，先得到执行，优先级也是由用户确定的，这是用户仅有的权力。</p><h3 id="hook调用"><a href="#hook调用" class="headerlink" title="hook调用"></a>hook调用</h3><p>形式比较优雅</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_hook</span><span class="params">(self, fn_name)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> hook <span class="keyword">in</span> self._hooks:</span><br><span class="line">        getattr(hook, fn_name)(self)</span><br></pre></td></tr></table></figure><p>用户仅仅需要实现自己所需要的hook，如果没有自定义的hook，框架会调用父类Hook中相应的方法。父类Hook可能提供了一些默认行为，也可能什么都没做。</p><h3 id="hook实现"><a href="#hook实现" class="headerlink" title="hook实现"></a>hook实现</h3><p>Hook设计举例之OptimizerHook，实现了after_train_iter挂载点方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OptimizerHook</span><span class="params">(Hook)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, grad_clip=None)</span>:</span></span><br><span class="line">        self.grad_clip = grad_clip</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clip_grads</span><span class="params">(self, params)</span>:</span></span><br><span class="line">        clip_grad.clip_grad_norm_(</span><br><span class="line">            filter(<span class="keyword">lambda</span> p: p.requires_grad, params), **self.grad_clip)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">after_train_iter</span><span class="params">(self, runner)</span>:</span></span><br><span class="line">        runner.optimizer.zero_grad()</span><br><span class="line">        runner.outputs[<span class="string">'loss'</span>].backward()</span><br><span class="line">        <span class="keyword">if</span> self.grad_clip <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.clip_grads(runner.model.parameters())</span><br><span class="line">        runner.optimizer.step()</span><br></pre></td></tr></table></figure><p>其实实现hook时，用户的疑问往往是自定义hook需要使用的数据从哪里来？显然用户不知道Run类中有哪些数据。用户其实是知道的，因为Run中原本是没有数据的，它仅是一个流程执行类，其中的数据均来自与用户创建run时传入的，如runner.optimizer。所以可以看到，一个hook仅仅需要两个元素，一个是执行者，这里是runner，另外一个是执行时间（触发条件，挂载点），这里是after_train_iter。</p><div class="note info"><p>注意一个hook类中具有所有挂载点，但是不必要实现所有挂载点方法，仅需实现本hook需要实现的挂载点方法</p></div><h3 id="hook注册"><a href="#hook注册" class="headerlink" title="hook注册"></a>hook注册</h3><p>hook的注册过程比较简单，因为触发是按框架定义的流程顺序主动调用的，因此仅需要按优先级插入到有序列表中即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_hook</span><span class="params">(self, hook, priority=<span class="string">'NORMAL'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Register a hook into the hook list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        hook (:obj:`Hook`): The hook to be registered.</span></span><br><span class="line"><span class="string">        priority (int or str or :obj:`Priority`): Hook priority.</span></span><br><span class="line"><span class="string">            Lower value means higher priority.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">assert</span> isinstance(hook, Hook)</span><br><span class="line">    <span class="keyword">if</span> hasattr(hook, <span class="string">'priority'</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'"priority" is a reserved attribute for hooks'</span>)</span><br><span class="line">    priority = get_priority(priority)</span><br><span class="line">    hook.priority = priority</span><br><span class="line">    <span class="comment"># insert the hook to a sorted list</span></span><br><span class="line">    inserted = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self._hooks) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> priority &gt;= self._hooks[i].priority:</span><br><span class="line">            self._hooks.insert(i + <span class="number">1</span>, hook)</span><br><span class="line">            inserted = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> inserted:</span><br><span class="line">        self._hooks.insert(<span class="number">0</span>, hook)</span><br></pre></td></tr></table></figure><p>如果有一个hook需要在两个不同时机执行两个需求，如在before_train_epoch和after_train_epoch，但是恰巧这两个需求的优先级不同，这个时候建议写成两个hook，每个hook只负责做一件事，这也是编程中一般原则吧。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>如果编写过windows窗体程序（如MFC），hook应该很容易理解，因为在MFC中回调太普遍了，这也是入门难（或者说难深入底层）的原因，框架默默帮你做了很多事，导致新入局者看不到全局。</p><p>这种Google风格docstring，我也是比较喜欢的，层次清楚，无多余字符，符合它本来的目的。可能是看惯了，统一就好。</p><p>BTW，其实这个知识不应该写在python目录下的，但是如果想到一个知识就按一般化分类，最后可能发现分类太多，知识缺少具体场景依托。因为以后的文章可能位置比较随性~</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/mybigkid/article/details/78383898" target="_blank" rel="noopener">https://blog.csdn.net/mybigkid/article/details/78383898</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之深浅拷贝</title>
      <link href="/Python/copy.html"/>
      <url>/Python/copy.html</url>
      
        <content type="html"><![CDATA[<p>本文主要讨论<code>copy</code>和<code>view</code>或者说<code>deep copy</code>和<code>shallow copy</code>。下文使用<code>深拷贝</code>一词表示复制对象的每一个元素。使用<code>浅拷贝</code>一词表示仅复制对象的浅层。在讨论与Numpy相关知识时使用拷贝表示对数组数据的深拷贝，使用<code>视图</code>一词表示共享数组数据。</p><h2 id="Q1-从list构造array，使用复制还是视图？"><a href="#Q1-从list构造array，使用复制还是视图？" class="headerlink" title="Q1 从list构造array，使用复制还是视图？"></a>Q1 从list构造array，使用复制还是视图？</h2><p>A1 如果list中是相同基本数据类型（int, float等），则采用copy，否则采用view。因为如果list保存如字典这类数据，np的数组没法以连续内存保存这些数据，因此不得不采用view形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">4</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>][<span class="string">'a'</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[&#123;<span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'a'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">4</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="Python内置数据类型嵌套结构的浅拷贝"><a href="#Python内置数据类型嵌套结构的浅拷贝" class="headerlink" title="Python内置数据类型嵌套结构的浅拷贝"></a>Python内置数据类型嵌套结构的浅拷贝</h2><p><img src="/images/1568258910146.png" alt="1568258910146"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的继承</title>
      <link href="/Python/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF.html"/>
      <url>/Python/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF.html</url>
      
        <content type="html"><![CDATA[<h2 id="init行为"><a href="#init行为" class="headerlink" title="init行为"></a>init行为</h2><p>当在Python中出现继承的情况时，一定要注意初始化函数_init_的行为:</p><ul><li>如果子类没有定义自己的初始化函数，父类的初始化函数会被默认调用；但是如果要实例化子类的对象，则只能传入父类的初始化函数对应的参数，否则会出错。</li><li>如果子类定义了自己的初始化函数，而在子类中没有显示调用父类的初始化函数，则父类的属性不会被初始化</li><li>如果子类定义了自己的初始化函数，在子类中显示调用父类，子类和父类的属性都会被初始化</li></ul><p>B继承A，C继承B，A有init，B没有init，C如有则不调用A的init，没有则调用A的init</p><h3 id="字符串文档"><a href="#字符串文档" class="headerlink" title="字符串文档"></a>字符串文档</h3><p>文档字符串对于类，函数/方法，以及模块来说是唯一的，也就是说doc属性是不能从父类继承。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python背后的方法</title>
      <link href="/Python/magic_method.html"/>
      <url>/Python/magic_method.html</url>
      
        <content type="html"><![CDATA[<h3 id="getattr"><a href="#getattr" class="headerlink" title="_ __getattr _ __"></a>_ __getattr _ __</h3><p><code>object. __getattr__(self, name)</code>是一个对象方法，如果找不到对象的属性时会调用这个方法。</p><p>这个方法应该返回属性值或者抛出<code>AttributeError</code>异常。</p><p>注意，如果通过正常机制能找到对象属性的话，不会调用<code>__getattr__</code>方法。</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Frob</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, bamf)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.bamf = bamf</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Frob does not have `&#123;&#125;` attribute.'</span>.format(str(name))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Frob(<span class="string">"bamf"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.bar</span><br><span class="line"><span class="string">'Frob does not have `bar` attribute.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.bamf</span><br><span class="line"><span class="string">'bamf'</span></span><br></pre></td></tr></table></figure><p>这个方法可以实现用属性（键）的方式访问字典值。mmcv中Config类即是这种用法的典范。</p><h3 id="getattr-1"><a href="#getattr-1" class="headerlink" title="getattr"></a>getattr</h3><p><code>getattr (object, name[, default])</code>是Python的内置函数之一，它的作用是获取对象的属性。</p><ul><li>object 对象</li><li>name 属性名</li><li>default 当属性不存在时，返回的默认值</li></ul><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.x = x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(f, <span class="string">'x'</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.x</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(f, <span class="string">'y'</span>, <span class="string">'bar'</span>)</span><br><span class="line"><span class="string">'bar'</span></span><br></pre></td></tr></table></figure><p><code>__getitem__</code></p><p><code>[]</code>运算符调用的函数</p><p>参看：</p><p><a href="https://www.jianshu.com/p/219e962e4f35" target="_blank" rel="noopener">https://www.jianshu.com/p/219e962e4f35</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象创建过程</title>
      <link href="/Python/object_generate_process.html"/>
      <url>/Python/object_generate_process.html</url>
      
        <content type="html"><![CDATA[<p> 对象的生命过程：创建、初始化、使用、垃圾回收，不同的阶段由不同的方法（角色）负责执行。 </p><p> <code>__new__</code> 方法 负责创建对象， 这个对象会传递给 <code>__init__</code> 方法中定义的 self 参数，以便实例对象可以被正确地初始化。 </p><p> <code>__init__</code>方法 负责对象的初始化 ，系统执行该方法前，该对象已经存在。 如果 <code>__new__</code> 方法不返回值（或者说返回 None）那么 <code>__init__</code> 将不会得到调用。此外，Python 还规定，<code>__init__</code> 只能返回 None 值，否则报错。</p><p> <code>__call__</code> 方法，不得不先提到一个概念，就是<em>可调用对象（callable）</em>，我们平时自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一对括号<code>()</code>应用到某个对象身上都可称之为可调用对象，判断对象是否为可调用对象可以用函数 <code>callable</code> 。 如果在类中实现了 <code>__call__</code> 方法，那么实例对象也将成为一个可调用对象</p><p>上面三个方法都称为魔术方法，因为这些方法不是由用户调用的，而是由解释器调用的。</p><p>此外，对象的回收工作是由GC(Garbage Collection)完成的，GC也是解释器的一部分。现代语言的垃圾回收算法都可以写好多内容。</p><p>参考：</p><ul><li><a href="https://foofish.net/magic-method.html" target="_blank" rel="noopener">https://foofish.net/magic-method.html</a></li><li><a href="https://www.jianshu.com/p/1e375fb40506" target="_blank" rel="noopener">https://www.jianshu.com/p/1e375fb40506</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/Python/queue.html"/>
      <url>/Python/queue.html</url>
      
        <content type="html"><![CDATA[<p>其实好多包都实现了队列这种数据结构，本篇重点介绍multiprocessing(mp)库的队列数据结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Queue type using a pipe, buffer and thread</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, obj, block=True, timeout=None)</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, block=True, timeout=None)</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qsize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Raises NotImplementedError on Mac OSX because of broken sem_getvalue()</span></span><br><span class="line">        <span class="keyword">return</span> self._maxsize - self._sem._semlock._get_value()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._poll()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">full</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._sem._semlock._is_zero()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Simplified Queue type -- really just a locked pipe</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleQueue</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._poll()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>可见SimpleQueue基本只实现了队列的get/put方法，而Queue还可查询队列的很多状态</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯虚函数</title>
      <link href="/C++/pure_virtural_func.html"/>
      <url>/C++/pure_virtural_func.html</url>
      
        <content type="html"><![CDATA[<p>C++允许为纯虚函数提供默认实现。</p><p>Q1：含默认实现的纯虚函数成员的基类（非派生类）能否实例化对象？</p><p>A：在VS2017中无法编译通过，对此一个合理的解释是：编译器不去检查含纯虚函数的非派生类是否提供了默认实现。含纯虚函数的非派生类唯一使用方式是被继承。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之对象内存模型</title>
      <link href="/C++/object_memory_model.html"/>
      <url>/C++/object_memory_model.html</url>
      
        <content type="html"><![CDATA[<h2 id="对象内存大小"><a href="#对象内存大小" class="headerlink" title="对象内存大小"></a>对象内存大小</h2><p>首先确定类的构成：<br>1) 数据成员：内置类型，类类型<br>2) 函数成员：虚函数、非虚函数  </p><h3 id="1）数据成员"><a href="#1）数据成员" class="headerlink" title="1）数据成员"></a>1）数据成员</h3><p>内置类型大小，字节为单位</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char <span class="number">1</span> </span><br><span class="line">short <span class="number">2</span> </span><br><span class="line"><span class="built_in">int</span> <span class="number">4</span> </span><br><span class="line">long <span class="number">4</span> </span><br><span class="line"><span class="built_in">float</span> <span class="number">4</span> </span><br><span class="line"><span class="built_in">double</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>主要有3条规则：</p><ol><li>结构体内的成员的首地址相对于结构体首地址的偏移量是其类型大小的整数倍，比如说double型成员相对于结构体的首地址的地址偏移量应该是8的倍数。</li><li>结构体（或类对象）的大小等于结构体（或类对象）内最大成员大小的整数倍。</li><li>为了满足规则1和2编译器会在结构体（或类对象）成员之后进行字节填充。</li></ol><h3 id="2）函数成员"><a href="#2）函数成员" class="headerlink" title="2）函数成员"></a>2）函数成员</h3><p>函数成员是不占用内存中类的对象的字节。C++中为了兼容C语言，也允许<code>struct</code> 作为类的声明。在C语言中<code>struct</code>是用来声明结构体类型的，只不过C中的结构体没有函数成员。 同样 C++中允许的函数成员，只不过是类给函数提供了一个作用域。<br>一个对象调用函数的时候，可以等价为普通函数的调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">A a;</span><br><span class="line">a.f();</span><br></pre></td></tr></table></figure><p><code>a.f();</code>等价于调用<code>f(&amp;a);</code>类中的成员函数（<code>static</code> 成员函数除外）形参中都有个隐含的<code>this</code> 指针，它指向类对象本身。 当对象 a 调用<code>f()</code>的时候，它会把a 的地址传给<code>this</code> 指针，所以<code>f()</code>就等价执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="keyword">const</span> A* <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象内存大小计算举例"><a href="#对象内存大小计算举例" class="headerlink" title="对象内存大小计算举例"></a>对象内存大小计算举例</h3><p>例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line">A a;</span><br><span class="line"><span class="comment">// 对象a的内存大小sizeof(a) = 8 bytes</span></span><br><span class="line"><span class="comment">// c 放在起始位置0，占1 个字节。 </span></span><br><span class="line"><span class="comment">// i 是int 要4 字节对齐，所以前面要空3 字节</span></span><br><span class="line"><span class="comment">// 最后类要按照他最长的数据成员对齐，就是i, 是4 字节对齐.因为已经占用了8 个字节， </span></span><br><span class="line"><span class="comment">// 8 是对齐4 的，所以不用额外增加字节数了</span></span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">doube d;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">A a;<span class="comment">// eg.1 中的类类型A</span></span><br><span class="line">&#125;;</span><br><span class="line">B b;</span><br><span class="line"><span class="comment">// 对象b 的内存大小sizeof(b)=24</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">d 放在起始位置0到7，占8个字节。 </span></span><br><span class="line"><span class="comment">c 是char 要1字节对齐，所以放在位置8，占1个字节。 </span></span><br><span class="line"><span class="comment">b 是类类型，在eg.1中知道它是8字节对齐的，所以前面要空7个字节，它从位置16 </span></span><br><span class="line"><span class="comment">开始存储，一直到23，占8个字节。 </span></span><br><span class="line"><span class="comment">最后类要按照他最长的数据成员对齐，也就是8字节对齐，因为已经占用了24个字 </span></span><br><span class="line"><span class="comment">节，24是对齐8 的，所以不用额外增加字节数了。最后sizeof(a)=24。 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="对象内存结构"><a href="#对象内存结构" class="headerlink" title="对象内存结构"></a>对象内存结构</h2><h3 id="1-基类"><a href="#1-基类" class="headerlink" title="1 基类"></a>1 基类</h3><ul><li>有虚函数：先存放虚函数表指针，然后存放自己的数据成员</li><li>没有虚函数：直接存放数据成员</li></ul><h3 id="2-单一继承派生类"><a href="#2-单一继承派生类" class="headerlink" title="2 单一继承派生类"></a>2 单一继承派生类</h3><ul><li>无虚函数：先存放父类的数据拷贝(包括虚函数表指针)，然后是本类的数据</li><li>有虚函数： 同基类有虚函数情况，且本类虚函数表中，先存放父类的虚函数，再存放子类的虚函数 </li><li>重载了父类的某些虚函数： 新的虚函数将虚函数表中父类的这些虚函数覆盖 </li></ul><p>单一继承派生类，派生类无虚函数<br> <img src="https://img-blog.csdn.net/20160722112216494" alt="单一继承派生类，派生类无虚函数"> </p><p>单一继承派生类，派生类有虚函数<br> <img src="/images/20160722112345621" alt="单一继承派生类，派生类有虚函数"> </p><p>单一继承派生类，派生类有虚函数，且存在虚函数重载<br> <img src="/images/20160722112820733" alt="单一继承派生类，派生类有虚函数，且存在虚函数重载"> </p><h3 id="3-多重继承派生类"><a href="#3-多重继承派生类" class="headerlink" title="3 多重继承派生类"></a>3 多重继承派生类</h3><ul><li>无虚函数： 先存放第一个父类的数据拷贝，在存放第二个父类的数据拷贝，依次类推，最后存放自己的数据成员。 其中每一个父类拷贝都包含一个虚函数表指针 </li><li>有虚函数：本类的虚函数表，存储于第一个父类的虚函数表后边部分</li></ul><p>多重继承，子类无虚函数<br> <img src="/images/20160722114314570" alt="多重继承，子类无虚函数"> </p><p>多重继承，子类有虚函数<br> <img src="/images/20160722114406801" alt="多重继承，子类有虚函数"> </p><p>上图Child5的int child5数据上面一个int base3应改为int base4，这里写错误了。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之内存类型</title>
      <link href="/C++/memory_type.html"/>
      <url>/C++/memory_type.html</url>
      
        <content type="html"><![CDATA[<p>一个由C/C++编译的程序占用的内存根据其用途和操作方式分为以下几个部分</p><h2 id="栈区（stack）"><a href="#栈区（stack）" class="headerlink" title="栈区（stack）"></a>栈区（stack）</h2><p>程序运行时由系统自动分配，存放函数的参数值，局部变量（自动变量）的值等。其操作方式类似于数据结构中的栈。程序结束后由系统释放</p><ul><li>由系统自动分配， 速度较快， 程序员无法控制这部分内存分配</li><li>只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出 </li><li>在Windows下，<strong>栈内存是向低地址扩展的</strong>，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</li><li>在函数调用时，第一个进栈的是函数调用语句的下一条可执行语句的地址，然后是函数的各个参数，在大多数的C编译器中，<strong>参数是由右往左入栈的</strong>，然后是函数中的局部变量，静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是函数调用语句的下一条指令，程序由该点继续运行。</li></ul><h2 id="堆区（heap）"><a href="#堆区（heap）" class="headerlink" title="堆区（heap）"></a>堆区（heap）</h2><p>在内存开辟另一块存储区域。一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。由程序员手动释放</p><ul><li>程序员手动分配，分配速度较慢，且容易产生内存碎片</li><li>操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</li><li>对于大多数系统，会在这块内存空间中的首地址处（ 占一个字节 ）记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 </li><li><strong>堆内存是向高地址扩展的</strong>，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li></ul><h2 id="全局区（静态区）（static）"><a href="#全局区（静态区）（static）" class="headerlink" title="全局区（静态区）（static）"></a>全局区（静态区）（static）</h2><p>编译器编译时即分配内存。全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由系统释放。</p><h2 id="文字常量区"><a href="#文字常量区" class="headerlink" title="文字常量区"></a>文字常量区</h2><p>常量字符串就是放在这里的。 程序结束后由系统释放</p><h2 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a>程序代码区</h2><p>存放函数体的二进制代码。 程序结束后由系统释放</p><p>注意：这里的内存是软件上人为划分的几个区域。从硬件看，它们所占有的内存结构都是相同的。那么为什么软件上给这些内存取不同名字加以区分呢。原因是内存的使用方式不同（管理方式）。栈内存是先申请的后释放其操作方式类似数据结构中的栈，因此得名栈内存。类似的堆内存，实际上也没有堆内存这种硬件，仅仅是因为这块内存操作方式类似于数据结构中的链表。程序员一般仅需要关注堆内存和栈内存，防止堆内存泄露和栈内存溢出。</p><h2 id="栈堆内存比较"><a href="#栈堆内存比较" class="headerlink" title="栈堆内存比较"></a>栈堆内存比较</h2><ul><li><p>管理方式不同：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p></li><li><p>空间大小不同：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。</p></li><li><p>能否产生碎片不同：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。</p></li><li><p>生长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p></li><li><p>分配方式不同：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p></li><li><p>分配效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p></li></ul><p>  虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生意想不到的结果。动态内存分配存在某些不确定因素，在某些场合下可能会禁止堆内存的使用，以提高软件可靠性。</p><h2 id="内存类型辨识例子"><a href="#内存类型辨识例子" class="headerlink" title="内存类型辨识例子"></a>内存类型辨识例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">// 全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1;   <span class="comment">// 全局未初始化区</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> b;<span class="comment">// 分配在栈内存上</span></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"abc"</span>; <span class="comment">// 分配在栈内存上</span></span><br><span class="line">    <span class="keyword">char</span> *p2; <span class="comment">// 分配在栈内存上</span></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="comment">// "123456/0"在常量区，p3在栈内存上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； <span class="comment">// 全局（静态）初始化区</span></span><br><span class="line">    p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);<span class="comment">// 分配的10和20字节的区域在堆内存上</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="comment">// 123456/0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="new-delete与malloc-free比较"><a href="#new-delete与malloc-free比较" class="headerlink" title="new/delete与malloc/free比较"></a>new/delete与malloc/free比较</h3><p>使用new分配堆空间可以调用类的构造函数，而malloc()函数仅仅是一个函数调用，它不会调用构造函数，它所接受的参数是一个unsigned long类型。同样，delete在释放堆空间之前会调用析构函数，而free函数则不会。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量申请</span></span><br><span class="line">Type* pointer = <span class="keyword">new</span> Type;</span><br><span class="line"><span class="keyword">if</span> (points != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// to do samething</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变量释放</span></span><br><span class="line"><span class="keyword">delete</span> pointer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组申请</span></span><br><span class="line">Type* pointer = <span class="keyword">new</span> Type[N];</span><br><span class="line"><span class="keyword">if</span> (points != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// to do samething</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组释放</span></span><br><span class="line"><span class="keyword">delete</span>[] pointer;</span><br></pre></td></tr></table></figure><h3 id="为什么栈相对于堆很小"><a href="#为什么栈相对于堆很小" class="headerlink" title="为什么栈相对于堆很小"></a>为什么栈相对于堆很小</h3><ul><li>并不是因为栈被设置的很小，所以我们不要在栈上放太大的东西。而是正常情况下我们不会在栈上放太大的东西（栈的作用），所以控制栈的大小让我们可以尽早的发现无穷递归，尽早失败；</li><li>Stack 的最顶端一般会留存在 CPU registers 和 cache 中。遇到频繁但是层次不多的函数调用，可以利用高速 cache。大块的内存会破坏这种优化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ofstream</title>
      <link href="/C++/ofstream.html"/>
      <url>/C++/ofstream.html</url>
      
        <content type="html"><![CDATA[<p>打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下： </p><ul><li>ios::app：　　　以追加的方式打开文件 </li><li>ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性 </li><li>ios::binary：　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文 </li><li>ios::in：　　　 文件以输入方式打开（文件数据输入到内存） </li><li>ios::out：　　　文件以输出方式打开（内存数据输出到文件） </li><li>ios::nocreate： 不建立文件，所以文件不存在时打开失败 </li><li>ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败 </li><li>ios::trunc：　　如果文件存在，把文件长度设为0  </li></ul><p>ofstream流</p><ul><li>ios::app，如果没有文件，那么生成空文件；如果有文件，那么在文件尾追加。 </li><li>ios::app | ios::in，不管有没有文件，都是失败。  ios::app不能用来打开输入流，即不能和ios::in相配合 </li><li>ios::ate，如果没有文件，那么生成空文件；如果有文件，那么清空该文件 </li><li>ios::ate | ios::in，如果没有文件，那么打开失败；如果有文件，那么定位到文件尾，并可以写文件，但是不能读文件 </li></ul><p>ifstream流</p><ul><li>ios::app，不管有没有文件，打开都是失败；</li><li>ios::ate，如果没有文件，打开失败；如果有文件，打开成功，并定位到文件尾，但是不能写文件</li></ul><p>fstream流</p><ul><li>默认是ios::in，所以如果没有文件，ios::app和ios::ate都是失败， </li><li>ios::app | ios::out，如果没有文件则创建文件，如果有文件，则在文件尾追加 </li><li>ios::ate | ios::out，如果没有文件则创建文件，如果有，则清空文件。 </li><li>ios::ate | ios::out | ios::in，如果没有文件，则打开失败，有文件则定位到文件尾</li></ul><p>每个文件流都应与一个打开的文件相联系:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1)在建立文件流对象的同时打开文件：</span></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"d:\\sav\\datafile.dat"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2)先建立文件流对象，再在适当的时候打开文件：</span></span><br><span class="line">ifstream fin;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">fin.open((<span class="string">"d:\\sav\\datafile.dat"</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">fin.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static关键字</title>
      <link href="/C++/static.html"/>
      <url>/C++/static.html</url>
      
        <content type="html"><![CDATA[<p><strong>local static变量</strong></p><p> 如果一局部变量被声明为static，那么将只有<strong>唯一</strong>的一个静态分配的对象，它被用于在该函数的所有调用中表示这个变量。这个对象将只在执行线程第一次到达它的定义使初始化。 构造函数是在控制线程第一次通过该对象的定义时调用。在程序结束时，局部静态对象的析构函数将按照他们被构造的相反顺序逐一调用，没有规定确切时间。 </p><ul><li><p>有唯一副本， 存放在内存的静态存储区域 </p></li><li><p>只在函数作用域内可见</p></li><li><p>可以用来设计单例模式的对象</p><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但是有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。　　静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，下次调用时值还是上次的调用结束的值。</p></li></ul><p><strong>global static变量</strong></p><ul><li>静态全局变量只在所在文件可见，非静态的全局变量在各个源文件中都是有效的</li><li>其它文件中可以定义相同名字的变量，不会发生冲突 </li><li>全局数据区（ 静态存储区域）分配内存 </li></ul><table><thead><tr><th>代码区</th></tr></thead><tbody><tr><td>全局数据区</td></tr><tr><td>堆区</td></tr><tr><td>栈区</td></tr></tbody></table><p>对局部静态变量对比</p><ul><li>局部变量改为静态变量后，改变了它的存储方式，即改变了它的生存期</li><li>全局变量改为静态变量后，改变了它的作用域， 限制了它的使用范围 </li></ul><p> <strong>静态成员变量和静态成员函数</strong> </p><p> 如果一个变量是类的一部分，但却不是该类的各个对象的一部分，它就被成为是一个static静态成员。</p><ul><li>一个static成员只有唯一的一份副本，而不像常规的非static成员那样在每个对象里各有一份副本</li><li>访问类静态成员，不需要通过特定对象去调用的函数</li><li>类的静态成员函数只能访问类的静态成员(变量或函数)</li></ul><p><strong>静态对象</strong></p><p>对于C语言的全局和静态变量，不管是否被初始化，其内存空间都是全局的；如果初始化，那么初始化发生在任何代码执行之前，属于编译期初始化。由于内置变量无须资源释放操作，仅需要回收内存空间，因此程序结束后全局内存空间被一起回收，不存在变量依赖问题，没有任何代码会再被执行！</p><p>C++引入了对象，这给全局变量的管理带领新的麻烦。C++的对象必须有构造函数生成，并最终执行析构操作。由于构造和析构并非分配内存那么简单，可以说相当复杂，因此何时执行全局或静态对象（C++）的构造和析构呢？这需要执行相关代码，无法在编译期完成，因此C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造，并通过atexit()来管理对象的生命期，在程序结束之后（如调用exit，main），按FILO顺序调用相应的析构操作！</p><p>简而言之，C++未规定不同编译单元静态对象的初始化次序（Effective C++，条款04对这个问题进行了讨论），全局或静态对象当且仅当对象首次用到时才进行构造。</p><p><strong>扩展</strong></p><p>​        术语static有着不寻常的历史。起初，在C中引入关键字static是为了表示退出一个块后仍然存在的局部变量。随后，static在C中有了第二种含义：用来表示不能被其它文件访问的全局变量和函数。为了避免引入新的关键字，所以仍使用static关键字来表示这第二种含义。最后，C++重用了这个关键字，并赋予它与前面不同的第三种含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数(与Java中此关键字的含义相同)。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针兼容性</title>
      <link href="/C++/pointer_compatibility.html"/>
      <url>/C++/pointer_compatibility.html</url>
      
        <content type="html"><![CDATA[<p>指指向基类和派生类的指针之间的兼容性。</p><p>指向基类的指针或引用可以引用派生类对象，而不必进行显示类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BrassPlus <span class="title">dilly</span><span class="params">(<span class="string">"Annie Dill"</span>, <span class="number">493222</span>, <span class="number">2000</span>)</span></span>;</span><br><span class="line">Brass * pb = &amp;dilly;<span class="comment">// ok</span></span><br><span class="line">Brass &amp; rb = &amp;dilly;<span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>将派生类引用或指针转换为基类引用或指针被称为向上强制类型转换，不需要进行显示转换；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">b</span><span class="params">(<span class="string">"Billy Bee"</span>, <span class="number">123432</span>, <span class="number">10000.0</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">bp</span><span class="params">(<span class="string">"Betty Beep"</span>, <span class="number">232313</span>, <span class="number">12345.0</span>)</span></span>;</span><br><span class="line">Brass * pb = &amp;b;</span><br><span class="line">BrassPlus * pbp = &amp;bp;</span><br><span class="line">pb = pbp;<span class="comment">// ok, 不需要显示转换</span></span><br></pre></td></tr></table></figure><p>将基类引用或指针转换为派生类引用或指针被称为向下强制类型转换，需要显示转换，否则编译不通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">b</span><span class="params">(<span class="string">"Billy Bee"</span>, <span class="number">123432</span>, <span class="number">10000.0</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">bp</span><span class="params">(<span class="string">"Betty Beep"</span>, <span class="number">232313</span>, <span class="number">12345.0</span>)</span></span>;</span><br><span class="line">Brass * pb = &amp;b;</span><br><span class="line">BrassPlus * pbp = &amp;bp;</span><br><span class="line">pbp = pb;<span class="comment">// 编译不通过, 需要显示转换</span></span><br><span class="line">pbp = <span class="keyword">static_cast</span>&lt;BrassPlus*&gt;(pb);<span class="comment">// ok</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组名、引用与指针区别</title>
      <link href="/C++/array_name_and_pointer.html"/>
      <url>/C++/array_name_and_pointer.html</url>
      
        <content type="html"><![CDATA[<h3 id="数组名与指针区别"><a href="#数组名与指针区别" class="headerlink" title="数组名与指针区别"></a>数组名与指针区别</h3><p>举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> *p;</span><br></pre></td></tr></table></figure><ul><li>数组名具有常量性，相当于<code>T* const</code></li><li>数组名作为函数参数时，常量性被摘除，与普通指针相同</li><li>数组名不是变量，不能做左值，因此不能自增自减之类操作</li><li>sizeof(数组名) 得到数组大小，sizeof(指针) 得到指针大小</li><li>&amp;p得到指针的地址；&amp;a得到数组地址</li></ul><h3 id="数组名与数组指针区别"><a href="#数组名与数组指针区别" class="headerlink" title="数组名与数组指针区别"></a>数组名与数组指针区别</h3><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*pa)[<span class="number">4</span>];  <span class="comment">// 数组指针，指向数组的起始地址</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">4</span>];  <span class="comment">// 数组名，指向数组首元素地址</span></span><br></pre></td></tr></table></figure><ul><li><p>运算方式不同。a+1，a的地址偏移一个char大小（1字节）；pa+1，pa的地址偏移一个指针大小（4字节）</p></li><li><p>是两种不同类型，如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">4</span>])</span></span>;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line">f3(b[<span class="number">1</span>]);<span class="comment">// 编译出错</span></span><br><span class="line">f3(&amp;b[<span class="number">1</span>]);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p>不能直接赋值，如<code>pa = a;</code>，但可以<code>pa = &amp;a;</code>。从上面例子也可看出。</p></li></ul><h3 id="数组指针与指针数组区别"><a href="#数组指针与指针数组区别" class="headerlink" title="数组指针与指针数组区别"></a>数组指针与指针数组区别</h3><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*pa)[<span class="number">4</span>];  <span class="comment">// 数组指针，pa指向大小为4的char数组的起始地址</span></span><br><span class="line"><span class="keyword">char</span> * pb[<span class="number">4</span>];  <span class="comment">// 指针数组，数组内存放的是char*指针，pb指向数组首元素地址</span></span><br></pre></td></tr></table></figure><ul><li>pa是一个指针，指向一个char [4]的数组，每个数组元素是一个char类型的变量</li><li>如果一个数组的每一个元素都是指针，则这个数组是一个指针数组，如pb</li></ul><h3 id="引用与指针区别"><a href="#引用与指针区别" class="headerlink" title="引用与指针区别"></a>引用与指针区别</h3><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之深浅拷贝</title>
      <link href="/C++/deep_copy.html"/>
      <url>/C++/deep_copy.html</url>
      
        <content type="html"><![CDATA[<p>C++在拷贝对象时默认做的浅拷贝。所谓浅拷贝，完成数据成员的一一复制。<br>当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，<br>则两类中的两个指针将指向同一个地址，这会产生两个问题：</p><ul><li>一个类对象释放了其指针指向的数据后，导致也指向这块数据的指针成为野指针（指针悬挂），产生潜在危险</li><li>另一个对象析构时，又释放了一次这块内存，对同一块动态内存执行2次以上释放的结果是未定义的，所以这将导致错误或程序崩溃。</li></ul><p>此时必须采用深拷贝。深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存指针指向的数据，<br>从而也就解决了指针悬挂和内存释放两次的问题。<br>简而言之，当数据成员中有指针时，复制构造函数必须要用深拷贝。</p><p>C++默认的拷贝构造函数是浅拷贝<br>浅拷贝就是对象的数据成员之间的简单赋值，如你设计了一个类而没有提供它的复制构造函数，<br>当用该类的一个对象去给另一个对象赋值时所执行的过程就是浅拷贝（默认的拷贝构造函数），如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">A(<span class="keyword">int</span> _data) : data(_data)&#123;&#125; </span><br><span class="line">A()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">b = a; <span class="comment">// 默认copy构造函数为浅拷贝，仅仅是数据成员之间的赋值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对象中没有其他的资源（如：堆，文件，系统资源等），则深拷贝和浅拷贝没有什么区别，但当对象中有这些资源时，例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">A(<span class="keyword">int</span> _size) : size(_size)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 其中有一段动态分配的内存 </span></span><br><span class="line">data = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">&#125;</span><br><span class="line">A()&#123;&#125;;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 析构时释放资源</span></span><br><span class="line"><span class="keyword">delete</span> [] data;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="keyword">int</span>* data;</span><br><span class="line"><span class="keyword">int</span> size; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">b = a; <span class="comment">// b和a对象的data指针指向同一块内存，会被释放两次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里b的指针data和a的指针指向了堆上的同一块内存，a和b析构时，b先把其data指向的动态分配的内存释放了一次，<br>而后a析构时又将这块已经被释放过的内存再释放一次。对同一块动态内存执行2次以上释放的结果是未定义的，所以这将导致错误或程序崩溃。<br>此外a析构时将数据内存释放，导致b中指针成为野指针，可能使用了b中野指针，这会产生问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">A(<span class="keyword">int</span> _size) : size(_size)</span><br><span class="line">&#123;</span><br><span class="line">         <span class="comment">// 其中有一段动态分配的内存 </span></span><br><span class="line">data = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">&#125; </span><br><span class="line">A()&#123;&#125;;</span><br><span class="line">A(<span class="keyword">const</span> A&amp; _A) : size(_A.size)  <span class="comment">// 必须要自己实现使用深拷贝的复制构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">         <span class="comment">// 深拷贝</span></span><br><span class="line">data = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">&#125;  </span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line">         <span class="comment">// 析构时释放资源</span></span><br><span class="line"><span class="keyword">delete</span> [] data;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="keyword">int</span>* data; </span><br><span class="line"> <span class="keyword">int</span> size;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    b = a; <span class="comment">// 调用自定义的copy构造函数，实现深拷贝 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：深拷贝和浅拷贝的区别是在对象状态中包含其它对象的引用时，拷贝一个对象，如果同时需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝。</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/u010700335/article/details/39830425" target="_blank" rel="noopener">https://blog.csdn.net/u010700335/article/details/39830425</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之派生类与基类的同名函数调用情况</title>
      <link href="/C++/%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%83%85%E5%86%B5.html"/>
      <url>/C++/%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%83%85%E5%86%B5.html</url>
      
        <content type="html"><![CDATA[<p>注意：这里仅讨论同名函数为非虚函数情况</p><h2 id="1-先看-非同名函数-调用情况"><a href="#1-先看-非同名函数-调用情况" class="headerlink" title="1 先看 非同名函数 调用情况"></a>1 先看 <code>非同名函数</code> 调用情况</h2><p>此种情况最简单，结论是可通过子类直接调用自己没有的父类函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'am base class printer."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deprive</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">new_print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'am deprive class printer."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deprive deprive;</span><br><span class="line">deprive.print();<span class="comment">// 可以通过子类对象直接调用基类的函数</span></span><br></pre></td></tr></table></figure><h2 id="2-函数名相同，形参的个数或类型不同的情况"><a href="#2-函数名相同，形参的个数或类型不同的情况" class="headerlink" title="2 函数名相同，形参的个数或类型不同的情况"></a>2 <code>函数名相同，形参的个数或类型不同</code>的情况</h2><p>结论：</p><ul><li>子类函数覆盖基类的同名函数，无法通过派生类直接调用基类同名函数（与Python可以直接调用父类函数也不同）</li><li>可以显示调用基类函数</li><li>可以使用基类指针指向派生类对象，通过指针调用基类函数</li><li>这种情况是最需要要关注的，不属于函数重载，注意区分</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deprive</span>:</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I have a int type parameter."</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Deprive deprive;</span><br><span class="line">deprive.print();<span class="comment">// 编译不通过，无法通过子类对象直接调用基类的同名方法</span></span><br><span class="line">deprive.Base::print(c);<span class="comment">// ok, 方法一：显示调用基类方法</span></span><br><span class="line">Base * pt;</span><br><span class="line">pt = &amp;deprive;</span><br><span class="line">pt-&gt;print();<span class="comment">// ok, 方法二：定义基类指针，让基类指针指向派生类对象，用指针调用基类函数</span></span><br></pre></td></tr></table></figure><h2 id="3-函数名相同，形参的个数和类型也相同的情况"><a href="#3-函数名相同，形参的个数和类型也相同的情况" class="headerlink" title="3 函数名相同，形参的个数和类型也相同的情况"></a>3 <code>函数名相同，形参的个数和类型也相同</code>的情况</h2><p>结论：</p><ul><li>子类覆盖父类同名函数，直接用子类对象调用同名函数会默认调用子类的函数。<br>这种情况下想调用基类方法，与<code>函数名相同，形参的个数或类型不同</code>的情况相同</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++智能指针</title>
      <link href="/C++/small_points.html"/>
      <url>/C++/small_points.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍C++的四个智能指针: auto_ptr, unique_ptr, shared_ptr, weak_ptr 其中后三个是c++11支持，并且第一个已经被C++11弃用。<br>智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。</p><a id="more"></a><h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a><code>auto_ptr</code></h2><ul><li>出现时间最早（C++98），现在（从C++11开始）已被弃用</li><li>采用所有权模式，但是限制不足</li><li>不能指向对象数组，其析构函数内使用的是delete而非delete[]</li><li><a href="https://blog.csdn.net/u014082714/article/details/44260975" target="_blank" rel="noopener">不能作为STL标准容器的元素</a></li></ul><p>智能指针出现的思想是使用类来管理资源，无须手动释放资源，减少内存泄露的机会。auto_ptr完成了这一目的。举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;// 智能指针所在头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remodel</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> * ps = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (weird_thing())</span><br><span class="line">        <span class="comment">// 2 当然这里可以手动增加delete语句，但肯定会有部分人忘记，而且异常安全并不总能保证</span></span><br><span class="line">        <span class="keyword">throw</span> exception();<span class="comment">// 1 当出现异常时，delete将不被执行，因此将导致内存泄露。</span></span><br><span class="line">    str = *ps; </span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remodel_auto_ptr</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str))；</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (weird_thing ())</span><br><span class="line">        <span class="keyword">throw</span> exception()； </span><br><span class="line">    str = *ps;</span><br><span class="line">    <span class="comment">// delete ps； NO LONGER NEEDED</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">// auto_ptr被销毁的同时，ps指向的内存也会被auto_ptr的析构函数delete掉</span></span><br></pre></td></tr></table></figure><p>但是auto_ptr对资源所有权的剥夺较为隐晦，从而又导致其它问题，即内存访问出错。举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remodel_auto_ptr</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str))；</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ps2(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"xxx"</span>))；</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ps2 = ps;<span class="comment">// 将所有权从ps转让给ps2，此时ps不再引用该字符串从而变成空指针 </span></span><br><span class="line">    <span class="keyword">if</span> (weird_thing ())</span><br><span class="line">        <span class="keyword">throw</span> exception()； </span><br><span class="line">    str = *ps;<span class="comment">// 访问出错</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以至于后来不得不对<code>auto_ptr</code>重新设计，从而产生了<code>unique_ptr</code> 、<code>shared_ptr</code>以及<code>weak_ptr</code>。<code>unique_ptr</code> 和<code>shared_ptr</code>分别从独占和共享角度出发对<code>auto_ptr</code>改进，规定了上文代码中<code>ps2 = ps</code>的行为。<code>weak_ptr</code>设计的目的主要用于解决<code>shared_ptr</code>循环引用问题。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><code>unique_ptr</code></h2><ul><li>用以代替auto_ptr</li><li>采用所有权模式，严格限制</li><li>临时右值允许转移所有权</li></ul><p><code>unique_ptr</code>直接不允许上文代码中<code>ps2 = ps</code>的赋值行为，从而避免<code>auto_ptr</code>情况下<code>ps</code>访问错误。但有时确实有使ps2和ps同时能访问某一对象的需求，所以又设计了shared_ptr</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><code>shared_ptr</code></h2><ul><li>采用共享所有权模式指向对象</li><li>使用<code>引用计数</code>机制管理对象被释放的时机</li></ul><p>Notes: 指针是指向对象还是引用对象？<code>引用计数</code>机制管理指针指向对象的个数，所以用引用似乎没有问题，但使用<code>引用</code>这个词又怕与引用类型混淆)</p><p>多个<code>shared_ptr</code>可以同时指向一个对象，当最后一个<code>shared_ptr</code>离开作用域时，对象内存才会自动释放。 似乎使用<code>unique_ptr</code>和<code>shared_ptr</code>非常完美，满足各种需求。但实际上总会出现这样一个问题：每引入一种机制解决现有问题，而又不可避免的带来其它问题。但是代价不一样。<code>shared_ptr</code>会产生循环引用问题，但这种问题发生的频率相比于使用auto_ptr的问题很低。</p><p>智能指针的循环引用概念比资源的独占或共享概念较复杂，举例说明之：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">// 为了省去一些步骤这里 数据成员也声明为public</span></span><br><span class="line">    <span class="comment">//weak_ptr&lt;B&gt; pb;</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; pb;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomthing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//        if(pb.lock())</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"kill A\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//weak_ptr&lt;A&gt; pa;</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; pa;</span><br><span class="line">    ~B()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"kill B\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sa(<span class="keyword">new</span> A());</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; sb(<span class="keyword">new</span> B());</span><br><span class="line">    <span class="keyword">if</span>(sa &amp;&amp; sb)</span><br><span class="line">    &#123;</span><br><span class="line">        sa-&gt;pb=sb;</span><br><span class="line">        sb-&gt;pa=sa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"sa use count:"</span>&lt;&lt;sa.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面A类中包含一个shared_ptr，B类也包含一个shared_ptr。A对象有sa以及sb-&gt;pa指向，引用数为2。A对象有sb以及sa-&gt;pb指向，引用数也为2。当离开main函数作用域时，sa和sb要被销毁，A和B对象各自引用数减1，由于引用数不为0，均无法被sa-&gt;pb和sb-&gt;pa删除，造成A、B对象均未被回收，内存泄露。</p><p>由此归纳出循环引用产生条件：</p><ul><li>至少含两个对象，且其中均为智能指针（强引用指针）</li><li>对象中的智能指针同时指向了这些对象，它们之间的指向构成一个环。</li></ul><p>打破循环引用的关键在于使环中任一对象的引用数为0，这要求某些对象相互引用时的引用数不能够增加。有如下方法（这些方法是或的关系，选其一即可）：</p><ul><li>将生命周期最短的类，其中的指针设计为普通指针</li><li>将类中的指针设计为弱引用智能指针 </li></ul><p>上面方法，仅仅是针对必须使用循环引用的情况。大部分情况是我们不小心造成了循环引用，此时修改引用逻辑即可。</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><code>weak_ptr</code></h2><ul><li>使用weak_ptr引用对象不增加引用数，因此称之为弱引用。</li><li>不能直接通过weak_ptr来访问资源。  在需要访问资源的时候weak_ptr为你生成一个shared_ptr，shared_ptr能够保证在shared_ptr没有被释放之前，其所管理的资源是不会被释放的。创建shared_ptr的方法是lock()方法。  </li><li>expired()方法用于检测所管理的对象是否已经释放。如果已经被释放，获取到的是一个空的shared_ptr（NULL）。</li></ul><h2 id="计划更新"><a href="#计划更新" class="headerlink" title="计划更新"></a>计划更新</h2><ul><li><input checked disabled type="checkbox"> weak_ptr</li><li><input disabled type="checkbox"> unique_ptr临时允许右值转移所有权</li><li><input disabled type="checkbox"> shared_ptr使用举例 </li><li><input disabled type="checkbox"> unique_ptr使用举例</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/20368881" target="_blank" rel="noopener">https://www.zhihu.com/question/20368881</a></li><li><a href="https://www.cnblogs.com/lanxuezaipiao/p/4132096.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanxuezaipiao/p/4132096.html</a></li><li><a href="https://blog.csdn.net/u014082714/article/details/44260975" target="_blank" rel="noopener">https://blog.csdn.net/u014082714/article/details/44260975</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-next写作</title>
      <link href="/hexo/hexo-next-write.html"/>
      <url>/hexo/hexo-next-write.html</url>
      
        <content type="html"><![CDATA[<p>hexo标签及Markdown标签在本站显示效果。<br>此页面长期更新。</p><a id="more"></a><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><div class="note info"><p></p><p>删除本地镜像注意点：</p><ol><li><p>删除前需要保证容器是停止的</p></li><li><p>rm删除容器，rmi删除镜像</p></li><li><p>顺序：先删除容器，再删除镜像</p></li></ol><p></p></div><h3 id="居中引用"><a href="#居中引用" class="headerlink" title="居中引用"></a>居中引用</h3><blockquote class="blockquote-center"><p>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本站更新记录</title>
      <link href="/hexo/blog-cfg.html"/>
      <url>/hexo/blog-cfg.html</url>
      
        <content type="html"><![CDATA[<p>此页面长期更新</p><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><h3 id="2019-12-20"><a href="#2019-12-20" class="headerlink" title="2019-12-20"></a>2019-12-20</h3><h4 id="首页文章仅预览"><a href="#首页文章仅预览" class="headerlink" title="首页文章仅预览"></a>首页文章仅预览</h4><p>位置：themes/next/_config.yml:219</p><figure class="highlight yml"><figcaption><span>themes/next/_config.yml:219</span><a href="http://yearito.cn" target="_blank" rel="noopener">链接地址</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure><p>Notes: 新版本移除了此变量，将此功能独立于主题，借助第三方实现</p><h4 id="启用valine评论功能"><a href="#启用valine评论功能" class="headerlink" title="启用valine评论功能"></a>启用valine评论功能</h4><p>位置：themes/next/_config.yml:381</p><p><a href="https://leancloud.cn" target="_blank" rel="noopener">服务提供商‘LeanCloud’</a>[国内厂商，现在要实名，你懂得]，<a href="https://juejin.im/post/5d790e706fb9a06af8250665" target="_blank" rel="noopener">文档</a></p><h4 id="部分文章开启或关闭版权和打赏"><a href="#部分文章开启或关闭版权和打赏" class="headerlink" title="部分文章开启或关闭版权和打赏"></a>部分文章开启或关闭版权和打赏</h4><p>位于：themes/next/layout/_macro/post.swig:349</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">############局部文章开启或关闭#############&#125;</span></span><br><span class="line">&#123;% <span class="keyword">if</span> post.reward !== <span class="literal">false</span> %&#125;</span><br><span class="line">  &#123;% <span class="keyword">if</span> (theme.alipay or theme.wechatpay or theme.bitcoin) and not is_index %&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;% include <span class="string">'reward.swig'</span> %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">############局部文章开启或关闭#############&#125;</span></span><br><span class="line">&#123;% <span class="keyword">if</span> post.copyright !== <span class="literal">false</span> %&#125;</span><br><span class="line">  &#123;% <span class="keyword">if</span> theme.post_copyright.enable and not is_index %&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;% include <span class="string">'my-copyright.swig'</span> with &#123; post: post &#125; %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭底部hexo和主题信息"><a href="#关闭底部hexo和主题信息" class="headerlink" title="关闭底部hexo和主题信息"></a>关闭底部hexo和主题信息</h4><p>位置：themes/next/_config.yml:45</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line"><span class="attr">  powered:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line"><span class="attr">    version:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><h4 id="代码复制功能"><a href="#代码复制功能" class="headerlink" title="代码复制功能"></a>代码复制功能</h4><p>参考：<a href="https://www.zhyong.cn/posts/ca02/" target="_blank" rel="noopener">https://www.zhyong.cn/posts/ca02/</a></p><p>Notes: Next7.1.1版本已集成此功能，使用配置开启</p><h2 id="计划配置"><a href="#计划配置" class="headerlink" title="计划配置"></a>计划配置</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul><li><input disabled type="checkbox"> 代码首行显示文件名</li><li><input disabled type="checkbox"> 代码复制提示复制成功，解决移动端复制按钮显示问题</li></ul><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><ul><li><input disabled type="checkbox"> 描述显示不佳</li><li><input disabled type="checkbox"> Note块换行有问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo命令</title>
      <link href="/hexo/Hexo-cmd.html"/>
      <url>/hexo/Hexo-cmd.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令</title>
      <link href="/docker/docker-cmd.html"/>
      <url>/docker/docker-cmd.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-docker安装"><a href="#1-docker安装" class="headerlink" title="1 docker安装"></a>1 docker安装</h2><p>从阿里云的<code>Docker CE 镜像源站</code>，<a href="https://help.aliyun.com/document_detail/60742.html" target="_blank" rel="noopener">安装文档</a></p><h2 id="2-docker服务启动与停止"><a href="#2-docker服务启动与停止" class="headerlink" title="2 docker服务启动与停止"></a>2 docker服务启动与停止</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br><span class="line">service docker stop</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">service docker status</span><br></pre></td></tr></table></figure><h2 id="3-查看状态"><a href="#3-查看状态" class="headerlink" title="3 查看状态"></a>3 查看状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a<span class="comment"># 容器，-a表示all, 无-a仅显示正在运行的</span></span><br><span class="line"><span class="comment"># 容器的状态共有 7 种：created|restarting|running|removing|paused|exited|dead</span></span><br><span class="line"><span class="comment"># see： https://www.cnblogs.com/fuyuteng/p/8847331.html</span></span><br><span class="line">docker images ls<span class="comment"># 查看镜像</span></span><br></pre></td></tr></table></figure><h2 id="4-拉取镜像"><a href="#4-拉取镜像" class="headerlink" title="4 拉取镜像"></a>4 拉取镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span><br><span class="line">docker pull anibali/pytorch:cuda-10.0</span><br></pre></td></tr></table></figure><h2 id="5从镜像创建容器"><a href="#5从镜像创建容器" class="headerlink" title="5从镜像创建容器"></a>5从镜像创建容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行镜像，创建容器</span></span><br><span class="line">docker run -it ubuntu:16.04 &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -p 10022:22 --shm-size 16G，共享内存设置</span></span><br><span class="line"><span class="comment"># 指定端口映射</span></span><br><span class="line">docker run --privileged --gpus all --shm-size 16G -dit -p host_port:container_port  imageid</span><br><span class="line"><span class="comment"># 使用 `-d` 参数时，容器启动后会进入后台</span></span><br><span class="line"><span class="comment"># -v 挂载主机目录到容器，如</span></span><br><span class="line">docker run -it -v /media:/media:ro ubuntu</span><br><span class="line"><span class="comment"># ro表示只读</span></span><br></pre></td></tr></table></figure><h2 id="6-运行和进入容器"><a href="#6-运行和进入容器" class="headerlink" title="6 运行和进入容器"></a>6 运行和进入容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start container_id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker attach &#123;Container ID&#125;</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &#123;container ID&#125; bash<span class="comment"># [ctrl+D]退出后不会终止容器运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line"><span class="built_in">exit</span><span class="comment">#  or ctrl+D</span></span><br></pre></td></tr></table></figure><h2 id="7-提交-删除操作"><a href="#7-提交-删除操作" class="headerlink" title="7 提交/删除操作"></a>7 提交/删除操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暂停容器</span></span><br><span class="line">docker stop &lt;name or id&gt;</span><br><span class="line"><span class="comment"># 暂停所有容器，慎用</span></span><br><span class="line">docker stop $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器，只有先停止容器运行才能删除</span></span><br><span class="line">docker rm &lt;name or id&gt;</span><br><span class="line"><span class="comment"># 删除所有容器，慎用</span></span><br><span class="line">docker rm $(docker ps -a -q)</span><br><span class="line"><span class="comment"># 删除已经停止的容器，慎用</span></span><br><span class="line">docker rm $(docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi &lt;image id&gt;</span><br><span class="line"><span class="comment"># 删除none镜像</span></span><br><span class="line">docker rmi $(docker images | grep <span class="string">"none"</span> | awk <span class="string">'&#123;print $3&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交容器创建镜像</span></span><br><span class="line">docker commit  -m=<span class="string">"提交的描述信息"</span>  -a=<span class="string">"作者"</span>   容器id   要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure><div class="note info"><p></p><p>删除本地镜像注意点：</p><ol><li><p>删除前需要保证容器是停止的</p></li><li><p>rm删除容器，rmi删除镜像</p></li><li><p>顺序：先删除容器，再删除镜像</p></li></ol><p></p></div><h2 id="8-使用nvidia-gpu"><a href="#8-使用nvidia-gpu" class="headerlink" title="8 使用nvidia gpu"></a>8 使用nvidia gpu</h2><p>必须安装nvidia-container-toolkit</p><p>see: <a href="https://github.com/NVIDIA/nvidia-docker#ubuntu-16041804-debian-jessiestretchbuster" target="_blank" rel="noopener">https://github.com/NVIDIA/nvidia-docker#ubuntu-16041804-debian-jessiestretchbuster</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add the package repositories</span></span><br><span class="line">distribution=$(. /etc/os-release;<span class="built_in">echo</span> <span class="variable">$ID</span><span class="variable">$VERSION_ID</span>)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用含CUDA镜像创建容器方式</span></span><br><span class="line">docker run --gpus all --entrypoint=/bin/bash -it &lt;imageid&gt;</span><br><span class="line"><span class="comment"># 如果需要nvcc之类工具，需要额外安装</span></span><br><span class="line">apt-get install -y cuda-core-8-0<span class="comment"># cuda-8.0</span></span><br></pre></td></tr></table></figure><h2 id="9-其它操作"><a href="#9-其它操作" class="headerlink" title="9 其它操作"></a>9 其它操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名容器</span></span><br><span class="line">docker rename 原容器名  新容器名</span><br><span class="line"><span class="comment"># 重命名镜像，这似乎不叫重命名，因为原有的名字还是存在的</span></span><br><span class="line">docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像详情</span></span><br><span class="line">docker inspect 镜像ID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存镜像为文件</span></span><br><span class="line">docker save -o 要保存的文件名 要保存的镜像</span><br><span class="line"><span class="comment"># 从文件载入镜像</span></span><br><span class="line">docker load --input 文件<span class="comment"># or docker load &lt; 文件名</span></span><br><span class="line"><span class="comment"># ref: https://blog.csdn.net/qq_36358942/article/details/79473472</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载宿主机的目录，-v选项</span></span><br><span class="line">docker run -it -v /media:/media 容器ID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker占用磁盘空间</span></span><br><span class="line">docker system df -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无 tag 的镜像)，慎用</span></span><br><span class="line">docker system prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将没有容器使用的Docker镜像也删掉了，慎用</span></span><br><span class="line">docker system prune -a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的类</title>
      <link href="/Python/python_class.html"/>
      <url>/Python/python_class.html</url>
      
        <content type="html"><![CDATA[<h2 id="Q1-在-init-内和在-init-外定义成员变量区别"><a href="#Q1-在-init-内和在-init-外定义成员变量区别" class="headerlink" title="Q1 在__init__内和在__init__外定义成员变量区别"></a>Q1 在<code>__init__</code>内和在<code>__init__</code>外定义成员变量区别</h2><p>A 变量定义在<code>__init__</code>之外, 该变量隶属于这个类，访问方式：<code>类名.变量</code>。通过类名称直接去修改<code>__init__</code>之外的变量，可以保持全局同步。变量定义在<code>__init__</code>之内，该变量隶属于这个实例对象，访问方式：<code>对象名.变量</code></p><h2 id="Q2-如何实现类似于C-Java之类语言的对对象成员或方法访问权限限制"><a href="#Q2-如何实现类似于C-Java之类语言的对对象成员或方法访问权限限制" class="headerlink" title="Q2 如何实现类似于C++/Java之类语言的对对象成员或方法访问权限限制"></a>Q2 如何实现类似于C++/Java之类语言的对对象成员或方法访问权限限制</h2><p>A  Python中没有访问控制的关键字，例如private、protected等等。但是，在Python编码中，有一些约定来进行访问控制。 变量名前加双下划线，可以使变量变为私有，无法从类外访问（并不准确，其实还是有方法可以访问），<strong>子类也不可访问</strong>（与C++不同），但是，如果一个属性以<code>__xxx__</code>的形式定义，那它又可以被外部访问了，以<code>__xxx__</code>定义的属性在Python的类中被称为特殊属性，有很多预定义的特殊属性可以使用，通常我们不要把普通属性用<code>__xxx__</code>定义。 以单下划线开头的属性<code>_xxx</code>虽然也可以被外部访问，但是，按照习惯，他们不应该被外部访问。 也就是说Python希望程序员遵守约定而不是从语言层面强制如此。</p><p>至于方法的使用控制，目前没找到相关文档。</p><p>题外话：在Python中，通过单下划线<code>_</code>来实现<strong>函数</strong>模块级别的私有化，变量除外。一般约定以单下划线<code>_</code>开头的函数为模块私有的，也就是说<code>from moduleName import *</code>将不会引入以单下划线<code>_</code>开头的函数。 </p><h2 id="Q3-如果一个类不继承自其它类-就显式的从object继承-嵌套类也一样"><a href="#Q3-如果一个类不继承自其它类-就显式的从object继承-嵌套类也一样" class="headerlink" title="Q3  如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样."></a>Q3  如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.</h2><p>A3 在Python3中不需显示的继承object，默认如果没有任何继承那么就继承object</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python2中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span>    </span><br><span class="line">    <span class="string">"""    不带object    """</span>    </span><br><span class="line">    name = <span class="string">"zhengtong"</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span>    </span><br><span class="line">    <span class="string">"""    带有object    """</span>    </span><br><span class="line">    name = <span class="string">"chonghong"</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:    </span><br><span class="line">    x = Person()    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Person"</span>, dir(x)     </span><br><span class="line">    y = Animal()    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Animal"</span>, dir(y)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person [<span class="string">'__doc__'</span>, <span class="string">'__module__'</span>, <span class="string">'name'</span>]</span><br><span class="line">Animal [<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, </span><br><span class="line"><span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, </span><br><span class="line"><span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'name'</span>]</span><br></pre></td></tr></table></figure><p> 不继承object对象，只拥有了<code>__doc__</code> , <code>__module__</code>和自己定义的变量， 继承object对象，拥有了好多可操作对象，这些都是对象都是类中的高级特性。  对于写大型项目来说，这些高级特性非常有用，比如说tornado里面的异常捕获时就有用到<code>__class__</code>来定位类的名称，还有高度灵活传参数的时候用到<code>__dict__</code>来完成。</p><p>这个区别在Python3中不复存在，为什么写这个？让你知道自己拥有了什么！</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const用法</title>
      <link href="/C++/const.html"/>
      <url>/C++/const.html</url>
      
        <content type="html"><![CDATA[<h1 id="const-char-ptr"><a href="#const-char-ptr" class="headerlink" title="const char ptr;"></a>const char <em>ptr;</em></h1><p>定义一个指向字符常量的指针</p><ul><li>ptr是一个指向 <code>char*</code> 类型的常量。</li><li>不能用ptr来修改所指向的内容，换句话说，*ptr的值为const，不能修改。</li><li>ptr的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对ptr而言，这个值是常量。</li></ul><p>实验如下：ptr指向str，而str不是const，可以直接通过str变量来修改str的值，但不能通过ptr指针来修改。</p><p> <img src="https://img-blog.csdn.net/20170809161324271" alt="img"> </p><h1 id="char-const-ptr"><a href="#char-const-ptr" class="headerlink" title="char const *ptr;"></a>char const *ptr;</h1><p>​    此种写法和const char *等价 </p><h1 id="char-const-ptr-1"><a href="#char-const-ptr-1" class="headerlink" title="char * const ptr;"></a>char * const ptr;</h1><p>​    定义一个指向字符的指针常数，即const指针</p><ul><li>不能修改ptr指针，但是可以修改该指针指向的内容</li></ul><p>实验如下：</p><p> <img src="https://img-blog.csdn.net/20170809161047098" alt="img"> </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
